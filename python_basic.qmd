---
title: "Básico de Python"
author: "Sergio Pedro Rodrigues Oliveira"
format:
    html:
        code-fold: true
        number-sections: true
    pdf:
      toc: false
      lof: false
      lot: false
      toc-depth: 5
      number-sections: true
      number-depth: 5
      colorlinks: true
      cite-method: biblatex
    docx:
      toc: true
      number-sections: true
      highlight-style: github
jupyter: python3
bibliography: Quarto/pythonbibliografia.bib
csl: Quarto/abnt.csl
---

\thispagestyle{empty}

\newpage
\pagenumbering{roman}

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\contentsname}{SUMÁRIO}
\tableofcontents
```

\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listfigurename}{LISTA DE FIGURAS}
\listoffigures
```
\newpage

```{=latex}
\setcounter{tocdepth}{4}
\renewcommand{\listtablename}{LISTA DE TABELAS}
\listoftables
```

```{python}
#| echo: false
#| error: false
#| warning: false
from IPython.display import Markdown
from tabulate import tabulate
import math
import statistics
import numpy as np
import pandas as pd
```

\newpage

# Diagrama de estudo

```{mermaid}
flowchart LR
  A[Python básico] --> B(Projeto)
  B --> C{Estatística}
  C --> E[Analise de dados]
  C --> F[Mineração de dados]
```

# Variáveis e tipos de dados simples

## `print()`
Print é uma função que exibe uma string na tela.

Exemplo: 

```{python}
print("string")
```

## `print()` com variáveis

Podemos usar a função `print()` para imprimir uma variável string.

Exemplo:

```{python}
message = "Hello world!"
print(message)
```

\pagenumbering{arabic}
\newpage

## Regras de nomes de variáveis

Regras ou diretrizes para usar variáveis em Python.

* Nomes de variáveis  deve conter apenas letras, números e underscores. Podemos começar a variável com letra ou underscore, mas nunca com um número.
* Espaços não são permitidos em nomes de variáveis, mas underscores podem ser usados para separar palavras.
* Evite usar palavras reservadas e nome de funções em Python como nome de variáveis.
* Nomes de variáveis devem ser concisos, porém descritivos.
* Tome cuidado ao usar a letra l e a letra maiuscula O, pois podem ser confundidas com os números 1 e 0.

\newpage

## Concatenando strings

Podemos usar o simbolo de (+) para combinar strings (concatenar).

Exemplo:

```{python}
first_name = "ada"
last_name = "lovelace"
full_name = first_name + " " + last_name
print("Hello, " + full_name.title() + "!")
```

Os espaços em branco entre aspas servem para criar espaços na string.

## Métodos auxiliares da função `print()`

1. `.title()`
   
  Coloca apenas as primeiras letras em maiúsculas de cada palavra e o resto em minúscula.

  Exemplo:

```{python}
full_name = "ada lovelace"
print(full_name.title())
```


2. `.upper()`

  Coloca todas as letras em maiúsculas.

  Exemplo:

```{python}
full_name = "ada lovelace"
print(full_name.upper())
```

3. `.lower()`

  Coloca todas as letras em minusculas.
  O método `.lower()` é particularmente útil para armazenar dados. Converter os dados em minúscula antes de armazenar.

  Exemplo:

```{python}
full_name = "ada lovelace"
print(full_name.lower())
```

\newpage

## Caracteres de escape

Podemos inserir alguns caracteres de escape no texto para executar alguma ação, como pular linha, gerar tabulação e etc. Alguns caracteres podem ser vistos na @tbl-caresc.

Todos os caracteres de escape começam com barra(`\`) + complemento.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-caresc
#| tbl-cap: Caracteres de escape

from IPython.display import Markdown
from tabulate import tabulate
table = [["`\\`t","Gera tabulação (tab)."],
         ["`\\`n","Gera quebra de linha."]]
Markdown(tabulate(
  table, 
  headers=["Caracteres de escape","Descrição"]
))
```

Exemplo:
```{python}
print("Language:\nPython\nJava\nC\nJavaScript")
```

\newpage

## Removendo espaços em branco `print()`

1. `.rstrip()`

  Remove espaço em branco do lado direito.

  Exemplo:
```{python}
favorite_linguage = 'python '
favorite_linguage.rstrip()
```

2. `.lstrip()`

  Remove espaço em branco do lado esquerdo.

  Exemplo:
```{python}
favorite_linguage = ' python'
favorite_linguage.lstrip()
```

3. `.strip()`

  Remove os espaços em branco dos dois lados ao mesmo tempo.

  Exemplo:
```{python}
favorite_linguage = ' python '
favorite_linguage.strip()
```

   * Os metodos usados não removem os espaços em branco em definitivo, para remover em definitivo é necessario armazenar o valor novo na variável.

```{python}
favorite_linguage = ' python '
favorite_linguage = favorite_linguage.strip()
favorite_linguage
```

\newpage

## Números

A linguagem Python faz tipagem automática (dinâmica), tipa a variável de acordo com o uso. E o Python contém uma tipagem forte, não faz converção automática do tipo de uma variável para executar uma ação (operação).

Em resumo, python tem é uma linguagem de tipagem dinâmica e forte.

Os principais tipos de dados no Python são estão presentes na @tbl-tiposdados.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-tiposdados
#| tbl-cap: Principais tipos de dados

from IPython.display import Markdown
from tabulate import tabulate
table = [["Inteiro","int","Números inteiros"],
         ["Ponto flutuante","float","Números com ponto decimal"]]
Markdown(tabulate(
  table, 
  headers=["Nome","Abreviação","Descrição"]
))
```

## Funções de conversão de tipo

Podemos converte variáveis para determinado tipo especificado usando funções de conversão de tipo, como pode ser obeservado na @tbl-functipo.

Converter uma variável não é permanente, a não ser que a ação seja armazenada na variável explicitamente.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-functipo
#| tbl-cap: Funções de conversão de tipo

from IPython.display import Markdown
from tabulate import tabulate
table = [["int","`int()`","Converte variável para o tipo inteiro(int)"],
         ["float","`float()`","Converte variável para o tipo float"],
         ["string","`str()`","Converte variável para o tipo string"]]
Markdown(tabulate(
  table, 
  headers=["Tipo para converter","Função","Descrição"]
))
```

A função `str()` é deveras importante, pois pode auxiliar na função `print()`. A função `print()` só imprime na tela veriáveis string, sendo assim, precisamos converter as variáveis de outros tipos para string (pelo menos, momentaneamente), para comprir essa condição.

Exemplo:

```{python}
age = 23
print("Happy " + str(age) + "rd Birthday!")
```

\newpage

## Descobrindo o tipo da variável usando a função `type()`

Podemos usar a função `type()` para descobrir o tipo de determinada variável.

```{python}
age = 23
print (type(age))
```

É uma **boa pratica** usar a função `type()`, para conferir o tipo da variável, antes de manipular alguma variável. Assim o programador terá o controle sobre as variáveis que esta trabalhando. Essa boa prática evita erros.

Também é uma **boa prática**, ao identificar/observar um erro, conferir os tipos das variáveis envolvidas. É um dos erros mais comuns: erro de tipagem.

\newpage

## Operações básicas

A @tbl-opbasicpy apresenta as principais operações básicas do python.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-opbasicpy
#| tbl-cap: Operações básicas

from IPython.display import Markdown
from tabulate import tabulate
table = [["Soma","+","2+2=4"],
         ["Subtração","-","3-2=1"],
         ["Multiplicação","*","2*3=6"],
         ["Divisão","/","5/4=1.25"],
         ["Divisão inteira","//","5//4=1"],
         ["Resto da divisão (módulo)","%","10%8=2"],
         ["Potência","**","3**2=9"],
         ["Raiz","**","4**0.5=2"]]
Markdown(tabulate(
  table, 
  headers=["Operação","Símbolo","Exemplo"]
))
```

\newpage

## Biblioteca `math` para ampliar operações matematicas

Podemos usar o pacote `math` para ampliar as funções matemáticas do Python (básicas, trigonométricas e estatísticas). A @tbl-opmathpy apresenta as principais funções básicas da biblioteca `math`.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-opmathpy
#| tbl-cap: Algumas operações da biblioteca `math`

from IPython.display import Markdown
from tabulate import tabulate
table = [["Soma","`math.add(x,y)`","`math.add(2,2) = (2+2)=4`"],
        ["Subtração","`math.subtract(x,y)`","`math.subtract(2,2) = (2-2)=0`"],
        ["Raiz quadrada","`math.sqrt()`","`math.sqrt(4)=2`"],
        ["Potência","`math.pow(x,y)`","`math.pow(2,3) = (2**3)=8`"],
        ["Seno","`math.sin()`","`math.sin()`, retorna um ângulo em radianos."],
        ["Cosseno","`math.cos()`","`math.cos()`, retorna um ângulo em radianos."],
        ["Tangente","`math.tan()`","`math.tan()`, retorna um ângulo em radianos."],
        ["potencia de Euler","`math.exp(x)`","`math.exp(x) = math.pow(math.e**x)`"],
        ["Logaritmo natural, ou log neperiano","`math.log(x)`","`math.log(2)=0.69`"],
        ["Logaritmo","`math.log(x[,base])`","`math.log(2,10)=0.3`"]]
Markdown(tabulate(
  table, 
  headers=["Operação","Símbolo","Exemplo"]
))
```

Para converter o ângulo para radianos podemos usar a função `math.radians()`.

```{python}
import math
#Seno do ângulo de 45°
#Resultado em Radianos
print(str(math.sin(math.radians(45))))
```

Para converter de radiano para grau podemos usar a função `math.degrees()`.

```{python}
import math
#Seno do ângulo de 45°
#Resultado em ângulo
print(str(math.degrees(math.sin(math.radians(45)))))
```

\newpage

## Operações lógicas básicas

A @tbl-opbasiclogpy apresenta as principais operações lógica básica do python. As operações lógicas retornam `True` ou `False`.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-opbasiclogpy
#| tbl-cap: Operações Lógicas Básicas

from IPython.display import Markdown
from tabulate import tabulate
table = [["==","Igual a","Varifica se um valor é igual ao outro.","1==1 = True"],
["!=","Diferente de","Varifica se um valor é diferente ao outro.","1!=2 = True"],
[">","Maior que","Varifica se um valor é maior que outro.","5>1 = True"],
[">=","Maior ou igual","Varifica se um valor é maior ou igual a outro.","5>=5 = True"],
["<","Menor que","Varifica se um valor é menor que outro.","1<5 = True"],
["<=","Menor ou igual","Varifica se um valor é menor ou igual a outro.","1<=4 = True"],
["and","E","Retorna True se ambas as afirmações forem verdadeiras.","(1==1) and (4<5) = True"],
["or","Ou","Retorna True se uma das afirmações for verdadeiras.","(1==1) or (2<1) = True"],
["not","Negação","Retorna Falso se o resultado for verdadeiro, ou o contrario.","not (1==1) = False"]]
Markdown(tabulate(
  table, 
  headers=["Operação","Nome","Função","Exemplo"]
))
```

\newpage

## Operadores de identidade

Os operadores de identidade, @tbl-opid, são utilizados para comparar objetos, se os objetos testados referenciam o mesmo objeto.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-opid
#| tbl-cap: Operadores identidade

from IPython.display import Markdown
from tabulate import tabulate
table = [["is","Retorna `True` se ambas as variáveis são o mesmo objeto."],
         ["is not","Retorna `True` se ambas as variáveis não são o mesmo objeto."]]
Markdown(tabulate(
  table, 
  headers=["Operador","Definição"]
))
```

Exemplo de operações de identidade:

```{python}
lista = [1,2,3]
outra_lista = [1,2,3]
recebe_lista = lista

print(f"São o mesmo objeto: {lista is outra_lista}")
```

```{python}
lista = [1,2,3]
outra_lista = [1,2,3]
recebe_lista = lista

print(f"São o mesmo objeto: {lista is recebe_lista}")
```

\newpage

## Operações de associação

Os operadores de associação, @tbl-opassoc, servem para verificar se determinado objeto esta **associado** ou **pertence** a determinada estrutura de dados.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-opassoc
#| tbl-cap: Operadores de associação

from IPython.display import Markdown
from tabulate import tabulate
table = [["in","Retorna `True` caso valor seja encontrado na sequência."],
         ["not in","Retorna `True` caso valor não seja encontrado na sequência."]]
Markdown(tabulate(
  table, 
  headers=["Operação","Função"]
))
```

Exemplos de operações de associação:

```{python}
lista = ["Python", 'Academy', "Operadores", 'Condições']
print('Python' in lista)
```

```{python}
lista = ["Python", 'Academy', "Operadores", 'Condições']
print('SQL' not in lista)
```

\newpage

## Comentários

Um comentário permite escrever notas em seus programas em liguagem natural. Em Python, o caractere sustenido (#) indica um comentário. Tudo que vier depois de um caractere sustenido en seu código será ignorado pelo interpretador Python.

**Boas práticas** em comentários:

1. Explicar o que o código deve fazer.

2. Como faz para funcionar.

\newpage

## Zen Python

É um guia de **boas práticas**.

```{python}
import this
```

Principais pontos:

1. Bonito é melhor do que feio.
   
2. Simples é melhor que complexo.

3. Complexo é melhor que complicado.

4. Legibilidade conta.

5. Deve haver uma - e, de preferência, 
apenas uma - maneira óbvia de fazer algo.

6. Agora é melhor que nunca.

\newpage

# Listas

## Lista

Uma lista é uma coleção de itens em uma ordem em particular. Os colchetes([]) indicam uma lista e os elementos individuais de uma lista são separados por vírgula. [ver @2023curso, pp. 71]

Exemplo:

```{python}
bicycles = ['trek','cannondale','redline','specialized']
print(bicycles)
```

## Acessando elementos de uma lista

Podemos acessar a qualquer item de uma lista informando a posição, ou índice. As posições de uma lista começam no 0, e não no 1.

Para acessar um elemento de uma lista, informamos o nome nome da lista seguido do índice do item entre colchetes.

Exemplo:

```{python}
#Acessando o primeiro item da lista
bicycles = ['trek','cannondale','redline','specialized']
print(bicycles[0].title())
```

Para acessar a lista de trás pra frente podemos usar a posição invertida seguida do símbolo de menos na frente. Sendo assim, a posição do último item é -1, do penúltimo -2 e assim sucessivamente.

Exemplo:

```{python}
#Acessando o último item da lista
bicycles = ['trek','cannondale','redline','specialized']
print(bicycles[-1].title())
```

\newpage

## Alterando, acrescentando e removendo elementos

Dado que a lista é um elemento dinâmico (pode, e provavelmente ocorrerá, de sofrer modificações com o uso), este tópico comentará os principais formas de modificação de listas.

### Modificando elementos de uma lista

Para alterar um elemento que você quer modificar, use o nome da lista seguido do índice do elemento que quer modificar, e então forneça um novo valor.

```{python}
#Alterando o item 1 da lista (índice 0)
motorcycles = ['honda','yamaha','suzuki']
motorcycles[0] = 'ducati'
print(motorcycles)
```

\newpage

### Acrescentando elementos em uma lista

Existem diversas formas de adicionar elementos a uma lista:

#### Concatenando elementos no final de uma lista, método `.append()`

Adiciona um novo elemento no final da lista usando o método `.append()`.

Exemplo:

```{python}
#Adicionando elemento ao final da lista
motorcycles = ['honda','yamaha','suzuki']
motorcycles.append('ducati')
print(motorcycles)
```

#### Inserindo elementos em uma lista, método `.insert()`

Este método insere um elemento em determinada posição da lista, usando o método `.insert(índice,elemento)`.

Exemplo:

```{python}
#Adicionando um item na segunda posição da lista (índice 1)
motorcycles = ['honda','yamaha','suzuki']
motorcycles.insert(1,'ducati')
print(motorcycles)
```

\newpage

### Removendo elementos de uma lista

Os métodos para remover um item, ou um conjunto de itens, de uma lista.

#### Instrução `del`

Se a posição do item que você quer remover de uma lista for conhecida, a instrução `del` remove (deleta) um item em qualquer determinada posição. Depois de removido (deletado) não podemos mais acessar o valor, quando usado a instrução `del`.

```{python}
# Remover (deletar) primeiro item da lista, indíce 0
motorcycles = ['honda','yamaha','suzuki']
print(motorcycles)

del motorcycles[0]
print(motorcycles)
```

#### Método `.pop()`

Existem duas formas de usar o método `.pop()`:

1. `.pop()`

As vezes há necessidade de usar o valor de um item depois de removê-lo de uma lista. O método `.pop()` remove o **último** item de uma lista, mas permite que você trabalhe com esse item depois da remoção.

Remove o primeiro item de uma pilha, ou seja, o último item de uma lista.

Para usarmos o item removido é necessário, salva-lo numa variável.

Exemplo:
```{python}
# Uso do método .pop()
# Removendo último item da lista e
# Trabalhando com o item removido.
motorcycles = ['honda','yamaha','suzuki']
print(motorcycles)

pop_motorcycle = motorcycles.pop()
print(motorcycles)
print(pop_motorcycle)
```

2. `.pop(índice)`

Podemos usar o `.pop()` para remover um item em qualquer posição em uma lista, se incluirmos o índice do item que você deseja remove entre parênteses.

Exemplo:
```{python}
# Uso do método .pop()
# Removendo o segundo item da lista e
# Trabalhando com o item removido.
motorcycles = ['honda','yamaha','suzuki']
print(motorcycles)

pop_motorcycle = motorcycles.pop(1)
print(motorcycles)
print(pop_motorcycle)
```

#### Método `.remove()`

Remove um item de acordo com o valor. É usado quando sabemos o valor do item, mas não a posição.

O método `.remove()` apaga apenas a primeira ocorrência do valor especificado. Para apagar mais de uma ocorrência será necessario o uso de um laço, para cada ocorrência.

Exemplo:

```{python}
# Uso do método .remove()
# Removendo um item da lista pelo valor
motorcycles = ['honda','yamaha','ducati']
print(motorcycles)

too_expensive = 'ducati'
motorcycles.remove(too_expensive)
print(motorcycles)
```

\newpage

## Organizando uma lista

Dado que com frequência, as listas são organizadas numa ordem imprevisível, se torna necessario organizar as informações em uma ordem particular. O Python tem mecanismos para organizar listas. São eles:

### Método `.sort()`

Ordena uma lista em ordem alfabética, ou alfabetica inversa.

Para ordenar uma lista em ordem alfabética inversa, basta passar o argumento `reverse = True` para o método `.sort()`.

Uma vez ordenada pelo método `.sort()` a lista não retorna a ordem original (ordenação permanente).

Exemplo:

```{python}
# Ordenando a lista cars usando o método .sort()
cars = ['bmw','audi','toyota','subaru']
print(cars)
cars.sort()
print(cars)
cars.sort(reverse=True)
print(cars)
```

\newpage

### A função `sorted()`

A função `sorted()` ordena uma lista de forma temporaria, não altera a lista original, em ordem alfabetica. Ou seja, a lista volta a forma orginal ao final do uso da função.

Assim como no médodo `.sort()`, podemos ordenar a lista em ordem alfabética inversa adicionando o argumento `reverse=True`.

Exemplo:

```{python}
# Ordenando temporariamente a lista cars usando a função sorted()
cars = ['bmw','audi','toyota','subaru']
print(cars)
print(sorted(cars))
print(sorted(cars,reverse=True))
print(cars)
```

\newpage

### Método `.reverse()` 

Para inverter a ordem original de uma lista, podemos usar o método `.reverse()`.

O método `.reverse()` não organiza a lista em ordem alfabética inversa, o método inverte a lista original.

O método `.reverse()` ordena de forma permanente a lista, porém se usarmos o método novamente, teremos a lista original. Logo, é fácil reverter o uso do método `.reverse()`.

Exemplo:

```{python}
# Método .reverse() para inverte, de modo permanete, a ordem da lista.
cars = ['bmw','audi','toyota','subaru']
print(cars)
cars.reverse()
print(cars)
cars.reverse()
print(cars)
```

\newpage

## Descobrindo o tamanho de uma lista - `len()`

Podemos descobrir o tamanho de uma lista usando a função `len()`.

Exemplo:

```{python}
cars = ['bmw','audi','toyota','subaru']
len(cars)
```

\newpage

# Trabalhando com listas

## Percorrendo uma lista inteira com um laço

Podemos usar um laço `for` para percorrer toda uma lista, podendo assim entre outras coisas, efetuar tarefas em cada item da lista.

A estutura básica do `for` é:

```
for variável_nova in lista :
  tarefas
```

O laço diz para a cada iteração pegar um elemento da lista e armazenar na nova variável, e executar uma tarefa a cada iteração. Toda tarefa indentada depois dos dois pontos é considerada dentro do laço.

No Python o `for`, usa indentação para determinar o que esta dentro do laço.

Qual quer linha após o laço que não for indentada é considerada fora do laço.

Exemplo:

```{python}
#Executando um laço com base numa lista
magicians = ['alice', 'david', 'carolina']
for magician in magicians:
  print(magician)
```

## Erros comuns de indentação

- Esquecer de indentar.
- Esquecer de indentar linhas adicionais do laço.
- Indentação desnecessaria.
- Indentando desnecessariamente após o laço.
- Esquecer os dois-pontos do laço `for`.

\newpage

## Listas numéricas

### Gerando série de números com a função `range()`

A função `range()` é usada para gerar uma série de números, de uma determinada sequência numérica.

A função `range()` faz o Python começar a contar no primeiro valor definido (limite inferior) e parar quando atingir o segundo valor definido (limite superior). Como o for para no segundo valor, a saída não conterá o valor final. Também podemos definir um intervalo, pulando alguns valores.

Estrutura da função `range()`:

`range(limite_inferior, limite_superior, intervalo)`

Exemplo:

```{python}
for value in range(1,5):
  print(value)
```

### Usando `range()` para gerar uma lista - `list()`

Podemos usar para criar uma lista de números, combinando a função `range()`, que gera uma série númerica, com a função `list()`, que cria um lista.

Exemplo:

```{python}
numbers = list(range(1,6))
print(numbers)
```

Exemplo 2:

```{python}
numbers = list(range(2,11,2))
print(numbers)
```

\newpage

### Estatística simples com lista de números

As principais funções estatísticas estão contidas na @tbl-estsimp.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-estsimp
#| tbl-cap: Estatística simples

from IPython.display import Markdown
from tabulate import tabulate
table = [["`min()`","Retorna o valor mínimo."],
         ["`max()`","Retorna o valor máximo."],
         ["`sum()`","Somatório."]]
Markdown(tabulate(
  table, 
  headers=["Funções","Descrição"]
))
```

As principais bibliotecas auxiliares de funções estatísticas são:

1. `math`
   
2. `numpy` as np

3. `statistics`

4. `Pandas` as pd

Medidas de posição utilizando bibliotecas python, @tbl-pacstatismedposition.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-pacstatismedposition
#| tbl-cap: Medidas de posição, bibliotecas python

from IPython.display import Markdown
from tabulate import tabulate
table = [["`np.mean()`","Média aritmética"],
         ["`statistics.median()`","Mediana"],
         ["`statistics.mode()`","Moda"],
         ["`np.quantiles(array, 0.5)`","Quartil"],
         ["`np.percentile(array, 50)`","Percentil"]]
Markdown(tabulate(
  table, 
  headers=["Funções","Descrição"]
))
```

Medidas de dispersão utilizando bibliotecas python, @tbl-pacstatismeddisp.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-pacstatismeddisp
#| tbl-cap: Medidas de dispersão, bibliotecas python

from IPython.display import Markdown
from tabulate import tabulate
table = [["`pd.var()`","Variância"],
         ["`pd.std()`","Desvio-padrão"],
         ["`pd.mad()`","Desvio absoluto"],
         ["`pd.cov()`","Covariância"],
         ["`pd.corr()`","Correlação"]]
Markdown(tabulate(
  table, 
  headers=["Funções","Descrição"]
))
```

\newpage

## list comprehensions

List comprehensions é uma forma de criar listas já acoplando o laço for nelas, deixando o código mais enxuto.

Sintaxe:

`nome_lista = [expressão_calculada_do_for for variável in range()]`

Exemplo:

```{python}
squares = [value ** 2 for value in range(1,11)]
print(squares)
```

\newpage

## Trabalhando com parte de uma lista

Neste tópico vamos trabalhar com um grupo de itens de uma lista, no Python é chamado de *fatia* (de uma lista).

### Fatiando uma lista

1. Fatia simples

  Para criar uma fatia, especifique o índice do primeiro e o último elemento com os quais você deseja trabalhar.

  O Python para em um item antes do segundo índice (índice final) especificado.

  Exemplo:

```{python}
#Exibindo os 3 primeiros elementos de uma lista.
players = ["charles","martina","michael","florence","eli"]
print(players[0:3])
#Serão exibidos os itens na posição 0, 1 e 2.
```

2. Delimitando ínicio e fim da fatia.

  Podemos começar de qualquer índice.

  Exemplo:

```{python}
#Exibindo do segundo ao quarto item.
players = ["charles","martina","michael","florence","eli"]
print(players[1:4])
```

\newpage

3. Omitindo índices

  Se omitirmos o primeiro índice, o Python começará do índice 0 (ínicio). De maneira analóga, se omitirmos o segundo índice (índice final), o Python terminará no último item.

  Exemplo:

```{python}
#Exibindo os 2 primeiros elementos de uma lista.
players = ["charles","martina","michael","florence","eli"]
print(players[:2])
```

4. índice negativo

  O índice negativo devolve um elemento a determina distância do final da lista. Assim podemos exibir qualquer fatia a partir do final da lista.

  Exemplo:

```{python}
#Exibindo os 3 últimos elementos de uma lista.
players = ["charles","martina","michael","florence","eli"]
print(players[-3:])
```


\newpage

### Percorrendo uma fatia com um laço - `for`

Podemos usar uma fatia em um laço `for` se quisermos percorrer um subconjunto de elementos de uma lista.

Exemplo:

```{python}
players = ["charles","martina","michael","florence","eli"]
print("Here are the first three players on my team:")
for player in players[:3]:
  print(player.title())
```

\newpage

### Copiando uma lista

Vamos explorar o modo de copiar uma lista e analisar uma situação em que copiar uma lista é útil.

1. Copiando uma lista inteira, usando *fatia*.

  Podemos criar uma fatia que inclua a lista inteira, omitindo o primeiro e segundo índices.

  Exemplo:

```{python}
#Usamos o metódo de fatia para copiar listas.
my_foods = ["pizza","falafel","carrot cake"]
friend_foods = my_foods[:]

print("My favorite food are:")
print(my_foods)

print("\nMy friend's favorite food are:")
print(friend_foods)
```

  Ambas as listas `my_foods` e `friend_fooods`, contém os mesmos elementos, porém são listas diferentes.
  Ao modificarmos uma delas a outra não é modificada automáticamente, por serem listas diferentes.

2. Variáveis que apontam para mesma lista.

  Se ao invés de copiarmos uma fatia de uma lista para a outra, mesmo que seja a lista inteira, definirmos que uma variável é igual a outra, nesse caso criamos duas variáveis que apontam para a mesma lista. Ou seja, se modificarmos qualquer uma das listas, a outra é automaticamente modificada, pois ambas são a mesma lista.

  Exemplo:

```{python}
#Ambas variáveis apontam para a mesma lista.
my_foods = ["pizza","falafel","carrot cake"]
friend_foods = my_foods

friend_foods.append("ice cream")

print("My favorite food are:")
print(my_foods)

print("\nMy friend's favorite food are:")
print(friend_foods)
```

\newpage

## Tuplas

Tuplas são listas em que os itens não são criadas para mudar (listas imutáveis).

### Definindo uma tupla

Uma tupla se parece com uma lista, exceto por usar parênteses no lugar de colchetes.

Sintaxe:

`tuplas = (valor_1,valor_2,valor_3,...)`

Exibimos cada elemento de uma tupla com a mesma sintaxe que usamos para acessar elementos de uma lista.

Exemplo:
```{python}
dimensions = (200,50)
print(dimensions[0])
```

Se tentarmos alterar algum elemento de uma tupla, será retornado um erro de tipo.

### Percorrendo todos os valores de uma tupla com um laço

Podemos percorrer uma tupla usando um laço `for`, da mesma forma que uma lista.

Exemplo:

```{python}
dimensions = (200,50)
for dimension in dimensions:
  print(dimension)
```

\newpage

### Sobrescrevendo uma tupla

Não é possível modificar os elementos de uma tupla. Retornaria um erro de tipo.

Esse tipo de operação não funcionaria:

`tupla[0] = valor_novo`

Porém é possível subrescrever a tupla, imputando novos valores a variável.

Exemplo:

```{python}
#Sobrescrevendo uma tupla
dimensions = (200,50)
print("Original dimensions:")
for dimension in dimensions:
  print(dimension)

dimensions = (400,100)
print("\nModified dimensions:")
for dimension in dimensions:
  print(dimension)
```

\newpage

# Estatística básica

## Teoria

- Definição de Estatística:
  
  A Estatística de uma maneira geral compreende aos métodos científicos para COLETA, ORGANIZAÇÃO, RESUMO, APRESENTAÇÃO e ANÁLISE de Dados de Observação (Estudos ou Experimentos), obtidos em qualquer área de conhecimento. A finalidade é a de obter conclusões válidas para tomada de decisões.

  - Estatística Descritiva
    
    Parte responsável basicamente pela COLETA e SÍNTESE (Descrição) dos Dados em questão.
  
    Disponibiliza técnicas para o alcance desses objetivos. Tais Dados podem ser provenientes de uma AMOSTRA ou POPULAÇÃO.

  - Estatística Inferencial
  
    É utilizada para tomada de decisões a respeito de uma população, em geral fazendo uso de dados de amostrais.

    Essas decisões são tomadas sob condições de INCERTEZA, por isso faz-se necessário o uso da TEORIA DA PROBABILIDADE.

- O fluxograma da estatística descritiva pode ser espresso da seguinte forma:

  ![Fluxograma da estatística descritiva.](Quarto/Imagens/Estatisica/fluxograma_estatistica_descritiva.png){}

\newpage

- A representação tabular (**Tabelas de Distribuição de Frequências**) deve conter:
  - Cabeçalho
  
    Deve conter o suficiente para que as seguintes perguntas sejam respondidas "**o que?**" (Relativo ao fato), "**onde?**" (Relativo ao lugar) e "**quando?**" (Correspondente à época).

  - Corpo
  
    É o lugar da Tabela onde os dados serão registrados. Apresenta colunas e sub colunas.

  - Rodapé
  
    Local destinado à outras informações pertinentes, por exemplo a Fonte dos Dados.

- População e Amostras:
  - População
  
    É o conjunto de todos os itens, objetos ou pessoas sob consideração, os quais possuem pelo menos uma característica (variável) em comum. Os elementos pertencentes à uma População são denominados "Unidades Amostrais".

  - Amostras
  
    É qualquer subconjunto (não vazio) da População. É extraída conforme regras pré-estabelecidas, com a finalidade de obter "estimativa" de alguma característica da População.

\newpage

- Tipos de variáveis
  
    ![Tipos de variáveis.](Quarto/Imagens/Estatisica/tipos_de_variaveis_estatistica.png){height=5cm}

  - *Qualitativo nominal*
  
    Não possuem uma ordem natural de ocorrência.
  
  - *Qualitativo ordinal*
  
    Possuem uma ordem natural de ocorrência.
  
  - *Quantitativo descreta*
  
    Só podem assumir valores inteiros, pertencentes a um conjunto finito ou enumerável.
  
  - *Quantitativo continua*
  
    Podem assumir qualquer valor em um determinado intervalo da reta dos números reais.

## Preparação dos dados (sumariazar dados coletados)

- Frequência (conceito)

  É a quantidade de vezes que um valor é observado dentro de um conjunto de dado.

- Distribuição em frequências
  - A distribuição tabular é denominada: "Tabela de Distribuição de Frequências".
  - Podemos separar em 3 modelos de distribuição tabular:
    - Variável Quantitativa Discreta.
    - Variável Quantitativa Contínua.
    - Variáveis Qualitativas.

\newpage

### Variável Quantitativa Discreta

- Passos da preparação dos dados:
  - 1º Passo - **DADOS BRUTOS**:   
    Obter os dados da maneira que foram coletados.
  
  - 2º Passo - **ROL**:   
    Organizar os DADOS BRUTOS em uma determinada ordem (crescente ou decrescente).
  
  - 3º Passo - **CONSTRUÇÃO TABELA**:  
    Na primeira coluna são colocados os valores da variável, e nas demais as respectivas frequências.
  
  - Frequência absoluta simples.  
    Nº de vezes que cada valor da variável se repete.

- Principais campos da **distribuição tabular de variaveis quantitativas discreta**:
  - $n$ é o número total de elementos da amostra.
  - $x_{i}$ é o número de valores distintos que a variavel assume.
  - $F_{i}$ é a Frequência Absoluta Simples.
  - $f_{i}$ é a Frequência Relativa Simples.
  - $f_{i} \%$ é a Frequência Relativa Simples Percentual. $f_{i}\% = f_{i} \cdot 100\%$.
  - $F_{a}$ é a Frequência Absoluta Acumulada.

  ![Distribuição tabular quantitativa discreta.](Quarto/Imagens/Estatisica/Distribuicao_tabular_quantitativo_discreta.png){height=5cm}

  Observação:  
  As setas simbolizam ordem crescente ou decrescente.

\newpage

### Variável Quantitativa Contínua

- Teoria:
  - A construção da representação tabular é realizada de maneira análoga ao caso das variáveis discretas.  
  - As frequências são agrupadas em classes, denominadas de "Classes de Frequência".  
  - Denominada "Distribuição de Frequências em Classes" ou "Distribuição em Frequências Agrupadas".  
  
  ![Distribuição de frequências em classes.](Quarto/Imagens/Estatisica/Distr_de_freq_em_classes.png){}

\newpage

- Convencionar o tipo de intervalo para as classes de frequência:

![Intervalo de classes, distribuição de frequências quantitativa continua.](Quarto/Imagens/Estatisica/Intervalo_classes-dist_freq_quant_continua.png){height=5cm}

![Distribuição frequências quantitativa continua, premissas.](Quarto/Imagens/Estatisica/Distribuicao_freq_quant_conti-premissas.png){height=5cm}

\newpage

Passos para contruir a **Tabela Distribuição de Frequências Contínua**:

1. Como estabelecer o **número de classes** ($k$):  
  - Normalmente varia de 5 a 20 classes.  
  - Critério fórmula de Sturges:  
  $$k \cong 1 + 3,3 \cdot \log (n)$$
  Onde $n$ é o número de elementos amostrais.  
  Arredondar $k$ para número inteiro.

  - Critério da Raiz quadrada:  
  $$k \cong \sqrt{n}$$  
  Onde $n$ é o número de elementos amostrais.  
  Arredondar $k$ para número inteiro.

\newpage

2. Como calcular a **Amplitude Total** ($AT_{x}$):  
  - Diferença entre o maior e o menor valor observado.  
  - Intervalo de variação dos valores observados.  
  - Aproximar valor calculado para múltiplo do nº classes ($k$).  
  - Garantir inclusão dos valores mínimo e máximo.  
  
  - Cálculo:  
    $$AT_{x} = Máx(X_{i}) - Mín(X_{i})$$
    Onde,  
    $AT_{x}$ é a Amplitude Total;  
    $Máx(X_{i})$ é o *valor máximo das amostras*;  
    $Min(X_{i})$ é o *valor mínimo das amostras*.  

  - Exemplo:  
    Se $k = 5$,  
    $AT_{x} = 28$  
    Logo, arredondando $AT_{x} = 30$, para aproximar o valor $AT_{x}$ de um múltiplo de $k$.  

\newpage

3. Como cálcular a **Amplitude das classes da frequência** ($h$):
  
  - As classes terão amplitudes iguais.
  - Cálculo:
    $$ h = h_{i} = \frac{AT_{x}}{k}$$
    Onde,  
    $k$ é o **número de classes** e $AT_{x}$ é a **Amplitude Total**.  
    $h$ deve ser arredondado para cima, num número inteiro.

4. Como determinar o ponto médio das classes, representatividade da classe ($p_{i}$):  
  $$p_{i} = \frac{(LS_{i} - LI_{i})}{2} $$
  Onde,  
  $LS_{i}$ é o limite superior da classe.  
  $LI_{i}$ é o limite inferior da classe.  

\newpage

5. Passos da preparação dos dados:
  - 1º Passo - **DADOS BRUTOS**:  
  Obter os dados da maneira que foram coletados.
  
  - 2º Passo - **ROL**:  
  Organizar os DADOS BRUTOS em uma determinada ordem (crescente ou decrescente).
  
  - 3º Passo - **CONSTRUÇÃO TABELA**:  
  Na primeira coluna são colocados as classes, e nas demais as respectivas frequências.
  
  - Exemplo:
  
    ![Tabela de_distribuição de frequência quantitativa continua.](Quarto/Imagens/Estatisica/tabela_de_dist_freq_quant_conti.png){height=5cm}
  
    $X_{i}$ são as classes.  
    $F_{i}$ é a Frequência Absoluta Simples.  
    $f_{i}$ é a Frequência Relativa Simples.  
    $f_{i} \%$ é a Fequência Relativa Simples Percentual.  
    $F_{a}$ é a Frequência Absoluta Acumulada.  
    $f_{a}$ é a Fequência Absoluta Acumulada Simples.  
    $f_{a} \%$ é a Fequência Absoluta Acumulada Simples Percentual.  
    $p_{i}$ é a Representatividade da classe (ponto médio das classes).  

\newpage

### Variáveis Qualitativas

- Passos da preparação dos dados:
  - Análogo ao procedimento para dados discretos.
  - 1º Passo - **DADOS BRUTOS**:  
  Obter os dados da maneira que foram coletados.
  - 2º Passo - **ROL**:  
  Nesse caso é feita organização dos DADOS BRUTOS em ordem (Crescente ou Decrescente) de importância.
  - 3º Passo - **CONSTRUÇÃO TABELA** (Com duas ou mais colunas).

- Distribuição de Frequencia:
  - $x_{i}$ é o número de valores distintos que a variável assume.
  - $F_{i}$ é a Frequência Absoluta Simples.
  - $f_{i}$ é a Frequência Relativa Simples.
  - $f_{i} \%$ é a Fequência Relativa Simples Percentual.
  - Inserir comentário sobre os dados.

\newpage

## Medidas de posição

- Localizar a *maior concentração de valores* de uma distribuição.
- *Sintetizar o comportamento* do conjunto do qual ele é originário.
- Possibitar a *comparação* entre séries de dados.
- As principais **medidas de posição** são:
  - **Média Aritmética** (Simples e Ponderada)
  - **Mediana**
  - **Moda**
  - **Separatrizes**
- Medidas de posição comparação:

![](Quarto/Imagens/Estatisica/medidas_de_posicao_comp.png){}

\newpage
  
### Média Aritmética (Simples e Ponderada)
- **Média Aritmética Simples**, dados Não-Agrupados (não tabelados):
  - **Média Aritmética** ($\overline{x}$) é o valor médio dos dados da distribuição.
  - É a soma de todos os elementos, dividido pelo número total de elementos.
  - Cálculo:
  $$\overline{x} = \frac{Soma}{n_{Total}}$$
- **Média Aritmética Ponderada**, dados Agrupados (tabelados):
  - Atribui-se um peso a cada valor da série.
  - É o *Ponto Médio das Classes* ($p_{i}$), multiplicado por suas respectivas *Frequência Absoluta Simples* ($F_{i}$), somadas. Dividido pelo *Número Total de Elementos da Amostra* ($n$).
  - Cálculo:
  $$\overline{x} = \frac{\sum_{i=1}^{n} p_{i} \cdot F_{i}}{n_{Total}}$$
  ou,
  $$\overline{x} = \frac{(p_{1} \cdot F_{1}) + (p_{2} \cdot F_{2})+(p_{3} \cdot F_{3}) + ...}{n_{Total}}$$

\newpage

### Mediana ($md(x)$)

#### Mediana Discreta
- Com dados em ROL, é o valor que divide o conjunto de dados em duas partes iguais.
- No caso de número de elementos impar, a mediana ($md(x)$) é o elemento central.
- No caso de número de elementos par, a mediana ($md(x)$) é a média aritmética simples dos valores centrais:
$$md(x) = \frac{x_{\frac{n}{2}} + x_{\frac{n+1}{2}}}{2}$$
Onde,  
$x$ é a posição do elemento;  
$n$ é o número total de elementos.

#### Mediana Contínua
- Mediana ($md$) em distribuição de frenquência em variável contínua (dados agrupados em classes):
  1. Fazer a coluna da **Frequência Absoluta Acumulada**, que é o somatório das frequências ao logo das classes.
   
  2. Definindo o **Intervalo da Mediana**.
    - Obter o número total de elementos $n$ (somatório das frenquências de classes),
    $$n = \sum f_i$$
    - Determinar a posição do elemento do meio do somatório das frequencias:
    $$x = \frac{\sum f_i}{2}$$
    - A classe que contém essa posição $x$ na **Frequência Absoluta Acumulada** é a classe do *intervalo da mediana*.
  
  3. Cálculo da Mediana:
  $$md = Li + (\frac{\frac{\sum fi}{2}-Fa_{anterior}}{f_{intervalo}} \cdot h)$$
  Onde,  
  $Li$ é o limite inferior do *intervalo da mediana*;  
  $\sum fi$ é o somatório das frequências (**frequência total** ($n$));  
  $Fa_{anterior}$ é a **Frequência Absoluta Acumulada** da classe anterior (linha anterior ao *intervalo da mediana*);  
  $f_{intervalo}$ é a **Frequência Absoluta Simples** do *intervalo da mediana*;  
  $h$ é a Amplitudade da classe do *intervalo da mediana*.  
  $$h = Ls - Li$$

\newpage

### Moda

- Moda ou $Mo(x)$: Valor com maior frequência de ocorrência em uma distribuição.
- Podem haver mais de um valor distinto com maior frequência, podendo assim ter mais de um valor na moda.

- Moda com frequência Continua:
  1. **Moda Bruta** ($M_{Bruta}$):
    - Achar a classe com maior frequência, esse será o *Intervalo Modal*.
    - Cálcular o *Ponto Médio* (Representatividade da classe) do *Intervalo Modal*:
    $$PM = \frac{LS + LI}{2}$$
    
    Onde,
    
    LS = Limite superior da classe;
    
    LI = Limite inferior da classe.
    
    - O *Ponto Médio* do *Intervalo Modal* será a **Moda Bruta**($M_{Bruta}$).
  
  2. **Moda King** ou **Moda do Rei** ($M_{King}$):
    - Determinar o intervalo (classe) com maior frequência, esse será o *Intervalo Modal*.
    - Cálculo da Moda de King ($M_{King}$):
    $$M_{King} = LI + (\frac{F_{post}}{F_{post}+F_{ant}} \cdot h)$$
    
    Onde,
    
    $LI$ é o limite inferior da classe do *Intervalo Modal*;
    
    $F_{post}$ é a frequência da classe posterior ao *Intervalo Modal*;
    
    $F_{ant}$ é a frequência da classe anterior ao *Intervalo Modal*;
    
    $h$ é a amplitude do intervalo da classe
    
    $$h = LS - LI$$
  
  3. **Moda de Czuber** ($M_{Czuber}$):
    - Determinar o intervalo (classe) com maior frequência, esse será o *Intervalo Modal*.
    - Cálculo da **Moda de Czuber** ($M_{Czuber}$):
    $$M_{Czuber} = LI + (\frac{\Delta_{ant}}{\Delta_{ant}+\Delta_{post}} \cdot h)$$
    
    Onde,
    
    $LI$ é o limite inferior da classe do *Intervalo Modal*;
    
    $\Delta_{ant}$ é a variação (diferença) da frequência da classe anterior (ao *Intervalo Modal*) com o *Intervalo Modal* (classe com maior frequência)
    $$\Delta_{ant} = |F_{i} - F_{i-1}|$$
    
    $\Delta_{post}$ é a variação (diferença) da frequência da classe posterior (ao *Intervalo Modal*) com o *Intervalo Modal* (classe com maior frequência)
    $$\Delta_{ant} = |F_{i} - F_{i+1}|$$
    
    $h$ é a amplitude do intervalo da classe
    
    $$h = LS - LI$$

\newpage

### Separatrizes

- **Separatrizes** são valores da distribuição que a dividem em partes quaisquer.
- A **mediana**, apesar de ser uma medida de tendência central, é também uma **separatriz** de ordem $1/2$, ou seja, divide a distribuição em duas partes iguais.
- As **separatrizes** mais comumente usadas são:
  - **Quartis**  
  Dividem a distribuição em quatro partes iguais, de ordem $1/4$.
  - **Decis**  
  Dividem a distribuição em 10 partes iguais, de ordem $1/10$.
  - **Centis**  
  Dividem a distribuição em 100 partes iguais, de ordem $1/100$.

- Fórmula das Separatrizes:

1. Achar o **Intervalo da separatriz**
  - É a classe em que se encontra a separatriz procurada.
  - Fazer a coluna de **Frequencia Absoluta Acumulada** ($F_a$).
  - É o somatório das frequencias (total das frequencias), multiplicado pela fração da separatriz procurada ($k$). O resultado é a posição da frequencia na coluna **Frequencia Absoluta Acumulada** ($F_a$).
  $$P_k = k \cdot \sum f_i$$
  A classe na qual a posição pertence é o **Intervalo da separatriz**.

2. Cálculo da separatriz:
$$Sp = L_{i} + (\frac{k \cdot\sum f_i - Fa_{anterior}}{f_{Intervalo}} * h)$$
Onde,  
$L_i$ é o limite inferior do **Intervalo da separatriz**;  
$k$ é a fração (porcentagem) da separatriz procurada;  
$\sum f_i$ é o somatório das frequências;  
$Fa_{anterior}$ é a **Frequência Absoluta Acumulada** da classe anterior ao **intervalo da separatriz**;  
$f_{Intervalo}$ é a **Frequência Absoluta Simples** do **intervalo da separatriz**;  
$h$ é a **Amplitude** da classe (limite superior - limite inferior da classe).
$$h = Ls - Li$$

\newpage

3. Cálculo de **Amplitude Interquartil** ($AI$):
- É a diferença entre 3º quartil e o 1º quartil.
$$AI = Q_3 - Q_1$$
- Para descobrir os valores dos Quartis ($Q_1$ e $Q_3$) basta usar o *cálculo das separatrizes*.

\newpage

## Medidas de dispersão

- Medem o grau de **variabilidade** (dispersão) dos valores observados em torno da **Média Aritmética**.

- Caracterizam a **representatividade da média** e o nivel de **homogeneidade** ou **heterogeneidade** dentro de cada grupo analizado.

![Exemplo de dispersão com heterogeneidade e homogeneidade.](Quarto/Imagens/Estatisica/medidas_de_dispersao.png){height=5cm}

### Amplitude Total ($A_T$)

- Diferença entre o maior e o menor dos valores da série.

- Não considera a dispersão dos valores internos, apenas os extremos.

- Utilização limitada enquanto medida de dispersão, oferece pouca informação.

- Cálculo:
$$A_T = X_{Máx} - X_{Mín}$$
Onde,  
$X_{Máx}$ é o valor máximo da série;  
$X_{Mín}$ é o valor mínimo da série.

\newpage

### Desvio

#### Desvio Absoluto ($D$)

- Para dados não agrupados:
  
  - Os **Desvios Absolutos** ($D$) são a diferença absoluta entre um valor observado e a média aritmética:
  $$D = |x_i - \bar{X}|$$
  Onde,  
  $x_i$ é o **valor de cada elemento**;  
  $\bar{x}$ é a **Média Aritmética**.  
  Os **Desvios Absolutos** ($D$) são um conjunto de elementos como resposta final.

- Para dados agrupados, sem intervalo de classe:
  
  - Cálculo:
  $$d_i = |x_i - \bar{X}|$$
  Onde,  
  $x_i$ é o valor da variável discreta;  
  $\bar{X}$ é a **Média Aritmética**.

- Para dados agrupados, com intervalo de classe:
  
  - Cálculo:
  $$d_i = |p_i - \bar{x}|$$
  Onde,  
  $p_i$ é a **Representatividade da classe** (ponto médio da classe);  
  $\bar{x}$ é a **Média Aritmética Ponderada** cálculada para *dados agrupados continuos*:
  $$\bar{x} = \frac{\sum_{i=1}^{N} p_i \cdot f_i}{\sum f_i}$$
  É o *Ponto Médio das Classes* ($p_{i}$), multiplicado por suas respectivas *Frequência Absoluta Simples* ($F_{i}$), somadas. Dividido pelo *Número Total de Elementos da Amostra* ($n$).
  
\newpage

#### Desvio Absoluto Médio ($dm$)

- É a **Média** dos **Desvios**.

- Para dados não agrupados:
  
  - Cálculo:
  $$dm(x) = \frac{\sum_{i=1}^{n} |x_i - \bar{x}|}{n}$$
  Onde,  
  $x_i$ é o **valor de cada elemento**;  
  $\bar{x}$ é a **Média Aritmética**;  
  $n$ é o **número total de elementos** (frequencia total).

- Para dados agrupados, sem intervalo de classe:
  
  - Cálculo:
  $$D_M = \frac{\sum |d_i| \cdot f_i}{n}$$
  Onde,  
  $d_i$ é o **Desvio Absoluto** para dados agrupados, sem intervalo de classe;  
  $f_i$ é a **Frequência** de cada variável discreta;  
  $n$ é o número total de elementos (ou somatório das frequências).

- Para dados agrupados, com intervalo de classe:
  
  - Cálculo:
  $$D_M = \frac{\sum |d_i| \cdot f_i}{\sum f_i}$$
  Onde,  
  $d_i$ é o **Desvio Absoluto** para dados agrupados, com intervalo de classe;  
  $f_i$ é a **frequência** de cada intervalo de classe.

\newpage

### Variância ($\sigma^2$ ou $S^2$)

- Leva em consideração os valores extremos e também os valores intermediários.

- Relaciona os desvios em torno da média (distancias dos valores ate a média).

- Média Aritmética dos quadrados dos desvios.

- O símbolo para **Variância Populacional** é o sigma ao quadrado ($\sigma^2$), já o símbolo para **Variância Amostral** é o "S" maiusculo ao quadrado ($S^2$).

- Cálculo para dados não agrupados:
  
  - População
  $$\sigma^2 = \sum_{i=1}^{N} \frac{(x_i - \bar{x})^2}{N}$$
  Onde,  
  $x_{i}$ é o valor de **cada elemento da série**;  
  $\bar{x}$ é o valor da **Média Aritmética Simples**;  
  $N$ é o **número total da população**.
  
  - Amostra
  $$S^2 = \sum_{i=1}^{n} \frac{(x_i - \bar{x})^2}{n - 1}$$
  Onde,  
  $x_{i}$ é o valor de **cada elemento da série**;  
  $\bar{x}$ é o valor da **Média Aritmética Simples**;  
  $n$ é o **número de elementos da Amostra**;  
  $(n -1)$ é por ser uma estimativa no caso da Amostra, trabalhando assim com um grau a menos de liberdade.
  
- Cálculo dados agrupados:
  
  - Para dados agrupados, sem intervalo de classe (**Variáveis Discretas**):
    
    - População
    $$\sigma^2 = \frac{\sum (x_i - \bar{X})^2 \cdot f_i}{\sum f_i}$$
    Onde,  
    $x_{i}$ é o valor de **cada elemento da série**;  
    $\bar{X}$ é o valor da **Média Aritmética Ponderada**;  
    $f_i$ é a **Frequência** da variável;  
    $\sum f_i$ é o somatório das **Frequências**.
    
    - Amostra
    $$S^2 = \frac{\sum (x_i - \bar{X})^2 \cdot f_i}{n - 1}$$
    Onde,  
    $x_{i}$ é o valor de **cada elemento da série**;  
    $\bar{X}$ é o valor da **Média Aritmética Ponderada**;  
    $f_i$ é a **Frequência** da variável;  
    $n - 1$ ou $\sum f_i - 1$ é o somatório das **Frequências** da Amostra menos 1.
  
  - Para dados agrupados, com intervalo de classe (**Variáveis Contínuas**):
    
    - População
    $$\sigma^2 = \frac{\sum (p_i - \bar{X})^2 \cdot f_i}{\sum f_i}$$
    Onde,  
    $p_{i}$ é a **Representatividade das Classe** (**Ponto Médio das Classes**);  
    $\bar{X}$ é o valor da **Média Aritmética Ponderada**;  
    $f_i$ é a **Frequência** da variável;  
    $\sum f_i$ é o somatório das **Frequências**.
    
    - Amostra
    $$S^2 = \frac{\sum (p_i - \bar{X})^2 \cdot f_i}{n - 1}$$
    Onde,  
    $p_{i}$ é a **Representatividade das Classe** (**Ponto Médio das Classes**);  
    $\bar{X}$ é o valor da **Média Aritmética Ponderada**;  
    $f_i$ é a **Frequência** da variável;  
    $n - 1$ ou $\sum f_i - 1$ é o somatório das **Frequências** da Amostra menos 1.

\newpage

### Desvio-padrão ($\sigma$ ou $S$)

#### Variância x Desvio-padrão

- **Variância**:

  - Número em unidade "quadrada".

  - Maior dificuldade de compreensão e menor utilidade na estatística descritiva.

  - Extremamente relevante na inferência estatística e em combinações de amostras.

- **Desvio-padrão**:

  - Mais usado na comparação de diferenças entre conjuntos de dados.

  - Determina a dispersão dos valores em relação a **Média**.

  - Volta-se com os dados para a unidade original.

#### Desvio-padrão (Populacional e Amostral)

- Determina a dispersão dos valores em relação a **Média**.

- População
$$\sigma = \sqrt{\sigma^2}$$
Onde,  
$\sigma^2$ é a **Variância Populacional**;  
$\sigma$ é o **Desvio-padrão Populacional**.

- Amostra
$$S = \sqrt{S^2}$$
Onde,  
$S^2$ é a **Variância Amostral**;  
$S$ é o **Desvio-padrão Amostral**.

\newpage

### Coeficiente de Variação ($CV$)

#### Teoria

- Medida relativa de dispersão.

- Útil para comparação em termos relativos do grau de concentração.

- O **Coeficiente de Variação** ($CV$) é expresso em porcentagens.

- Diz-se que uma distribuição:
  
  - $CV \leq 15\%$  tem **Baixa Dispersão**.
  
  - $15\% < CV < 30\%$  tem **Média Dispersão**.
  
  - $CV \geq 30\%$  tem **Alta Dispersão**.
  
#### Cálculo do Coeficiente de Variação

- População:
$$CV = \frac{\sigma}{\bar{X}} \times 100$$
Onde,  
$\sigma$ é o **Desvio-padrão Populacional**;  
$\bar{X}$ é a **Média Populacional**.

- Amostra:
$$CV = \frac{S}{\bar{x}} \times 100$$
Onde,  
$S$ é o **Desvio-padrão Amostral**;  
$\bar{x}$ é a **Média Amostral**.

\newpage

# Análise Estatística

- Para fazer uma Análise Estatística eficiente de dados, necessitamos:
  
  - Limpar os dados  
  Remover os *OUTLIER* (valores atipicos, inconsistentes).
  
  - Aplicar Estatística Descritiva aos dados  
  As medidas de posição (**Média**, **Mediana** e **moda**) e dispersão (**Amplitude Total**, **Desvio**, **Desvio Médio**, **Variância**, **Desvio-padrão** e **Coeficiente de Variação**) são maneiras de descrever os dados.
  
  - Comparar as medidas dos dados  
  Principalmente medidas de dispersão, me especial **Coeficiente de Variação**, são ótimas para comparar dados.
  
  - Previsão de dados  
  A principal técnica é de **Regressão**, porém para aplicar, necessita que os dados estejam limpos e com pouca dispersão (quanto menor, melhor).

\newpage

# Instruções `IF`

Instruções `IF` são testes condicionais.

## Testes condicionais

O serne da instrução `IF` esta uma expressão que deve ser avaliada como `True` ou `False`, chamado teste condicional. Esse teste decide se a instrução deve ser executada.

Teste condicional com resultado `True`, o código dentro do `IF` será executado.

Teste condicional com resultado `False`, o código dentro do `IF` não será executado.

## Operações lógicas

A @tbl-oplogpy apresenta as principais operações lógica do python. As operações lógicas retornam `True` ou `False`. A @tbl-oplogexpy mostra exemplos das operações lógicas.

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-oplogpy
#| tbl-cap: Operações Lógicas

from IPython.display import Markdown
from tabulate import tabulate
table = [["==","Igual a","Varifica se um valor é igual ao outro."],
["!=","Diferente de","Varifica se um valor é diferente ao outro."],
[">","Maior que","Varifica se um valor é maior que outro."],
[">=","Maior ou igual","Varifica se um valor é maior ou igual a outro."],
["<","Menor que","Varifica se um valor é menor que outro."],
["<=","Menor ou igual","Varifica se um valor é menor ou igual a outro."],
["and","E","Retorna True se ambas as afirmações forem verdadeiras."],
["or","Ou","Retorna True se uma das afirmações for verdadeiras."],
["not","Negação","Retorna Falso se o resultado for verdadeiro, ou o contrario."]]
Markdown(tabulate(
  table, 
  headers=["Operação","Nome","Função"]
))
```

\newpage

```{python}
#| echo: false
#| error: false
#| warning: false
#| label: tbl-oplogexpy
#| tbl-cap: Operações Lógicas Exemplos

from IPython.display import Markdown
from tabulate import tabulate
table = [["==","1==1 = True"],
["!=","1!=2 = True"],
[">","5>1 = True"],
[">=","5>=5 = True"],
["<","1<5 = True"],
["<=","1<=4 = True"],
["and","(1==1) and (4<5) = True"],
["or","(1==1) or (2<1) = True"],
["not","not (1==1) = False"]]
Markdown(tabulate(
  table, 
  headers=["Operação","Exemplo"]
))
```

Observações:  
 - Não confundir `=` com `==`. O sinal de `=` simples é uma atribuição de valor, enquanto que o sinal `==` duplo representa "igual a", sendo um operador lógico.  
 - Os operadores lógicos de igualdade (`==` e `!=`) fazem distinção entre letras maiúsculas e minúsculas.

\newpage

## Testando várias condições

Podemos testar duas (ou mais) condições ao mesmo tempo. Para isso as palavras reservadas `and` e `or` ajudam nesse tipo de situação.

### Testando várias condições lógicas - `AND`

O operador lógico `and` nada mais é do que o `E` da lógica, então podemos comparar duas operações lógicas e compara-las seguindo a ideia da tabela verdade do operador `E`.

![Tabela verdade do operador `AND`.](Quarto/Imagens/Instrucoes_if/AND.jpg){width=30%}

Exemplo:

```{python}
age_0 = 22
age_1 = 18
print(age_0 >= 21 and age_1 >= 21)
age_1 = 22
print(age_0 >= 21 and age_1 >= 21)
```

### Testando várias condições lógicas - `OR`

O operador lógico `or` nada mais é do que o `OU` da lógica, então podemos comparar duas operações lógicas e compara-las seguindo a ideia da tabela verdade do operador `OU`.

![Tabela verdade do operador `OR`.](Quarto/Imagens/Instrucoes_if/OR.jpg){width=30%}

Exemplo:

```{python}
age_0 = 22
age_1 = 18
print(age_0 >= 21 or age_1 >= 21)
age_0 = 18
print(age_0 >= 21 or age_1 >= 21)
```

\newpage

## Verificando se um valor está em uma lista - `IN`

Para descobrir se um valor em particular já esta em uma lista, utilizamos a palavra reservada `in`.

Exemplo:

```{python}
requested_toppings = ['mushrooms','onions','pineapple']
print('mushrooms' in requested_toppings)
print('pepperoni' in requested_toppings)
```

## Verificando se um valor não está em uma lista - `NOT IN`

Para descobrir se um valor em particular não esta em uma lista, utilizamos a palavra reservada `not in`.

Exemplo:

```{python}
banned_users = ['andrew','carolina','david']
user = 'marie'

if user not in banned_users:
  print(user.title() + ", you can post a response if you wish.")
```

## Expressões booleanas

Um valor booleano é `True` ou `False`, exatamente como o valor de uma expressão condicional após ter sido avaliada.  
Valores booleanos muitas vezes são usados para manter o controle de terminada condição.

```{python}
game_active = True
can_edit = True
```

## Instruções `IF`

Testes condicionais fazem parte das instruções `if`. Há vários tipos de instruções `if`, a escolha depende de quantas condições precisam ser testadas.

Os próximos subtópicos são as possibilidades de instruções `if`.

### Instruções `if` simples

A instrução `if` mais simples contém um teste e uma ação.  
Sintaxe:
```
if teste_condicional:
  ação
```

Ao avaliar o teste condicional e o resultado for `True`, as ações contidas dentro do `if` são executadas, caso contrario a ações contidas dentro da instrução `if` não são executadas.

Exemplo:
```{python}
age = 19
if age >= 18:
  print("You are old enough to vote!")
```

\newpage

### Instruções `if-else`

Um bloco `if-else` é semelhante a uma instrução `if` simples, porém a instrução `else` permite definir ação ou um conjunto de ações executado quando o teste condicional falhar.  
Sintaxe:
```
if teste_condicional:
  Ação_True
else:
  Ação_False
```

Exemplo:
```{python}
age = 17
if age >= 18:
  print("You are old enough to vote!")
else:
  print("Sorry, you are too young to vote.")
```

### Sintaxe `if-elif-else`

Muitas vezes se precisará testar mais de duas situações possíveis, para isso é usado a sintaxe `if-elif-else`. O Python executará apenas um bloco em uma cadeia `if-elif-else`. Cada bloco é executado em sequência, ate que algum deles passe. Quando um teste passar, o código após esse teste será executado e o Python ignorará o restante dos testes.  
Sintaxe:
```
if teste_condicional_1:
  Ação_teste_1
elif teste_condicional_2:
  Ação_teste_2
else:
  Ação_3
```

\newpage

Exemplo:
```{python}
age = 12
if age < 4:
  print("You admission cost is $0.")
elif age < 18:
  print("You admission cost is $5.")
else:
  print("You admission cost is $10.")
```

### Usando vários blocos `elif`

Podemos usar quantos blocos `elif` quisermos em nosso código.  
Sintaxe:
```
if teste_condicional_1:
  Ação_teste_1
elif teste_condicional_2:
  Ação_teste_2
elif teste_condicional_3:
  Ação_teste_3
elif teste_condicional_4:
  Ação_teste_4
else:
  Ação_5
```

Exemplo:
```{python}
age = 12
if age < 4:
  price = 0
elif age < 18:
  price = 5
elif age >= 65:
  price = 5
else:
  price = 10
print("Your admission cost is $" + str(price) + ".")
```

\newpage

### Omitindo o bloco `else`

Python não exige um bloco `else` no final de uma cadeia `if-elif`. As vezes um bloco `else` é útil, outras vezes, é mais claro usar uma instrução `elif` adicional que capture a condição específica de interesse.
`else` é uma função que captura tudo. Ela corresponde a qualquer condição não atendida por teste `if` ou `elif` específicos e isso, ás vezes, pode incluir dados inválidos ou maliciosos.
É uma boa prática considerar usar um último bloco `elif` e omitir o bloco `else`.  
Sintaxe:
```
if teste_condicional_1:
  Ação_teste_1
elif teste_condicional_2:
  Ação_teste_2
elif teste_condicional_3:
  Ação_teste_3
elif teste_condicional_4:
  Ação_teste_4
```

Exemplo:
```{python}
age = 12
if age < 4:
  price = 0
elif age < 18:
  price = 5
elif age >= 65:
  price = 5
elif age < 65:
  price = 10

print("Your admission cost is $" + str(price) + ".")
```

\newpage

### Testando várias condições

A cadeia `if-elif-else` é eficaz, mas é apropriada somente quando você quiser que apenas um teste passe. assim que encontrar um teste que passe, o interpretador Python ignorará o restante dos testes.  
As vezes, porém, é importante verificar todas as condições de interesse. Nesse caso, podemos usar um série de instruções `if` simples, sem blocos `elif` ou `else`.  
Em suma, se quiser que apenas um bloco de código seja executado, utilize uma cadeia `if-elif-else`. Se mais de um bloco de código deve ser executado, utilize uma série de instruções `if` independentes.  
Sintaxe:
```
if teste_condicional_1:
  Ação_teste_1
if teste_condicional_2:
  Ação_teste_2
if teste_condicional_3:
  Ação_teste_3
if teste_condicional_4:
  Ação_teste_4
```

Exemplo:
```{python}
#Pizzaria
requested_toppings = ['mushrooms','extra cheese']

if 'mushrooms' in requested_toppings:
  print("Adding mushrooms.")
if 'pepperoni' in requested_toppings:
  print("Adding pepperoni.")
if 'extra cheese' in requested_toppings:
  print("Adding extra cheese.")

print("\nFinished making your pizza!")
```

\newpage

## Usando instruções `if` com listas

Algumas tarefas interessantes podem ser feitas se combinarmos listas com instruções `if`. Podemos prestar atenção em valores especiais, que devem ser tratados de modo diferente de outros valores da lista.

### Verificando itens especiais

Podemos dar tratamento especial à determinado item de uma lista, criando um bloco especial de ação para ele.  
Exemplo de pizzaria de como tratar itens especiais:
```{python}
request_toppings = ['mushrooms','green peppers','extra cheese']
for request_topping in request_toppings:
  if request_topping == 'green peppers':
    print("Sorry, we are out of green peppers right now.")
  else:
    print("Adding " + request_topping + ".")
print("\nFinished making your pizza!")
```

\newpage

### Varificando se uma lista não esta vazia

Os usuários podem fornecer informações a serem armazenadas em uma lista, por isso não podemos supor que a lista não seja vazia. Nessa situação é conveniente testar se uma lista não esta vazia antes de executar um laço.  
Quando o nome de uma lista é usado em uma instrução `if`, o Python devolve `True` se a lista contiver pelo menos um item; Uma lista vazia é avaliada como `False`.

Exemplo:
```{python}
requested_toppings = []
if requested_toppings:
  for requested_topping in requested_toppings:
    print("Adding "+resquested_topping+".")
    print("\nFinished making your pizza!")
else:
  print("Are you sure you want a plain pizza?")
```

\newpage

### Usando várias listas

Ao útilizar mais de uma lista, podemos usar listas e instruções `if` para garantir que o dado de entrada faça sentido antes de atuar sobre ele.  
Um lista pode ser fechada (tupla) e representar o estoque da loja e outra lista o pedido do cliente. Assim teriamos que verificar o que bate e o que não bate entre as duas listas.

Exemplo:
```{python}
available_toppings = ('mushrooms','olives','green peppers','pepperoni','pineapple','extra cheese')

requested_toppings = ['mushrooms','french fries','extra cheese']

for requested_topping in requested_toppings:
  if requested_topping in available_toppings:
    print("Adding " + requested_topping + ".")
  else:
    print("Sorry, we don't have " + requested_topping + ".")
print("\nFinished making your pizza!")
```

\newpage

# Dicionários

## Dicionário simples

Os Dicionários permitem conectar informações relacionadas.  
Sintaxe:
```
nome_dicionario = {'chave_1': 'valor_1', 'chave_2':'valor_2', ...}
```

Exemplo:
```{python}
alien_0 = {'color':'green','points': 5}

print(alien_0['color'])
print(alien_0['points'])
```

## Trabalhando com dicionários

Um dicionário em Python é uma coleção de `chave-valor`. Cada `chave` é conectada a um `valor`, e podemos usar a `chave` para acessar o `valor` associado a ela.  
O `valor` pode ser um número, uma string, uma lista, ou até outro dicionário.  
Em Python o dicionário é apresentado entre chaves {}, com uma série de pares `chave-valor` entre elas.  
Exemplo:
```
alien_0 = {'color':'green','points': 5}
```

Um par `chave-valor` é um conjunto de valores associados um ao outro. Quando fornecemos uma `chave`, Python devolve o `valor` associado a essa `chave`. Toda `chave` é associada a seu `valor` por meio de dois-pontos, e pares `chave-valor` individuais são separados por vírgula.  
Podemos armazenar quantos pares `chave-valor` quisermos em um dicionário.

\newpage

## Acessando valores em um dicionário

Para obter o `valor` associado a uma `chave`, especifique o nome do dicionário e coloque a chave entre colchetes, como a seguir:
```{python}
alien_0 = {'color':'green'}
print(alien_0['color'])
```

Essa instrução devolve o `valor` associado a `chave` 'color' do dicionário `alien_0`.

Como podemos ter um número ilimitado de de pares de `chave-valor` em um dicionário, para acessar o valor de interesse basta colocar o nome da `chave` cujo o `valor` queremos acessar.

Exemplo:
```{python}
alien_0 = {'color':'green','points': 5}
new_points = alien_0['points']

print("You just earned " + str(new_points) + " points!")
```

Lembrando que números para serem plotados em tela precisam ser tranformados em strings, através da função `str()`.

\newpage

## Adicionando novos pares `chave-valor`

Dicionários são estruturas dinâmicas, e você pode adicionar novos pares `chave-valor` em um dicionário a qualquer momento. Por exemplo, para acrescentar um novo par `chave-valor`, especifique o nome do dicionário, seguido da nova chave entre colchetes, justamente com o novo valor.  
Exemplo:
```{python}
alien_0 = {'color':'green','points': 5}
print(alien_0)

alien_0['x_position'] = 0
alien_0['y_position'] = 25
print(alien_0)
```

A versão final do dicionário contém quatro pares `chave-valor`. Dois pares originais especificam a cor e o valor da pontuação, enquanto os dois pares adicionais especificam a posição do alienígena.  
Oberserve que a ordem dos pares `chave-valor` não coincidem com a ordem em que foram adicionados. O Python não se importa com a ordem em que armazenamos cada par `chave-valor`, ele só se importa com a conexão entre cada `chave` e seu `valor`.

\newpage

## Dicionário vazio

As vezes, é conveniente ou até mesmo necessário começar com um dicionário vazio e então acrescentar novos itens a ele. Para começar a preencher um dicionário vazio, defina-o com um conjunto de `chaves` vazio e depois acrescentar cada para par `chave-valor` em sua própria linha.  
Exemplo:
```{python}
alien_0 = {}

alien_0['color'] = 'green'
alien_0['points'] = 5

print(alien_0)
```

Nesse caso, definimos um dicionário `alien_0` vazio e, em seguida, adicionamos valores para cor e pontuação.

Geralmente usamos dicionários vazios quando armazenamos dados fornecidos pelo usuário em um dicionário, ou quando escrevemos um código que gere um grande número de pares `chave-valor` automaticamente.

## Modificando valores em um dicionário

Para modificar um `valor` em um dicionário, especifique o nome do dicionário com a `chave` entre conchetes e o novo `valor` que você quer associar a essa `chave`.  
Exemplo:
```{python}
alien_0 = {'color':'green'}
print("The alien is " + alien_0['color'] + ".")

alien_0['color'] = 'yellow'
print("The alien is now " + alien_0['color'] + ".")
```

Inicialmente, definimos um dicionário para `alien_0` que contém apenas a cor do alienigena. Em seguida, modificamos o `valor` associado a `chave` 'color' para 'yellow'.

\newpage

## Removendo pares `chave-valor`

Quando não houver mais necessidade de uma informação armazenada em um dicionário, podemos usar a instrução `del` para remover totalmente um par `chave-valor`.  
Tudo que `del` precisa é do nome do dicionário e da `chave` que você deseja remover.  
Exemplo:
```{python}
alien_0 = {'color':'green','points':5}
print(alien_0)

del alien_0['points']
print(alien_0)
```

A instrução `del` diz ao Python para apagar a `chave` 'points' do dicionário `alien_0` e remover o `valor` associado a essa `chave` também. A saída mostra que a `chave` 'points' e seu `valor` igual a 5 foram apagados, porém o restante do dicionário não foi afetado.

\newpage

## Dicionário de objetos semelhantes

O exemplo anterior envolveu a armazenagem de diferentes tipos de informação sobre o mesmo objeto: um alienigena em um jogo. Também podemos usar um dicionário para armazenar um tipo de informação sobre vários objetos.  
Por exemplo, suponha que você queira fazer uma enquete com várias pessoas e perguntar-lhes qual é a sua linguagem de programação favorita.  
Exemplo:
```{python}
favorite_languages = {
  'jen':'python',
  'sarah':'c',
  'edward':'ruby',
  'phil':'python'
  }

print("Sarah's favorite language is "+
    favorite_languages['sarah'].title()+
    ".")
```

Esse exemplo também mostra como podemos dividir uma instrução longa em várias linhas, indentando as linhas e usando algum operador como parâmetro para finalizar uma linha. No caso do `print` o operador de concatenação (+), no caso do dicionário a vírgula.

\newpage

## Percorrendo um dicionário com um laço

Como um dicionário pode conter uma grande quantidade de dados, Python permite percorrer um dicionário com um laço. Dicionários podem ser usados para armazenar informações de várias maneiras. Assim, há diversos modos diferentes de percorrê-los com um laço. Podemos percorrer todos os pares `chave-valor` de um dicionário usando suas `chaves` ou seus `valores`. 

### Percorrendo todos os pares `chave-valor` com um laço

Se quisermos ver tudo que está armazenado no dicionário, podemos percorrer o dicionário com um laço `for`.  
Exemplo:
```{python}
user_0 = {
  'username':'efermi',
  'first':'erico',
  'last':'fermi'
}
for key, value in user_0.items():
  print("\nKey: " + key)
  print("Value: " + value)
```

Para escrever um laço `for` paraum dicionário, devemos criar nomes para as duas variáveis que armazenarão a `chave` e o `valor` de cada par `chave-valor`. Podemos escolher qualquer nome que quisermos para essas duas variáveis.  
A instrução `for` inclui o nome do dicionário, seguido do método `items()`, que devolve uma lista de pares `chave-valor`. O laço `for` então armazena cada um desses pares nas duas variáveis especificadas.  
Observe que os pares `chave-valor` não são devolvidos na ordem em que foram armazenados, mesmo quando percorremos o dicionário com um laço. O Python não se importa com a ordem em que os pares `chave-valor` são armazenados. Ele só registra as conexões entre cada `chave` individual e seu `valor`.

\newpage

### Percorrendo todas as `chaves` de um dicionário com um laço

O método `key()` é conveniente quando não precisamos trabalhar com todos os valores de um dicionário.  
Exemplo:
```{python}
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python'
}

for name in favorite_languages.keys():
  print(name.title())
```

Extrai todas as `chaves` do dicionário `favorite_languages` e armazena, uma de cada vez, na variável `name`.

Percorrer as `chaves`, na verdade é o comportamento padrão quando percorremos um dicionário com um laço, portanto este código poderia ser escrito:
```
for name in favorite_languages:
```
em vez de:
```
for name in favorite_languages.keys():
```
Por boa prática optamos pelo método `keys()` pois torna o código mais explicito e de fácil leitura.

\newpage

O médoto `keys()` não serve apenas para laços, ele devolve uma lista de todas as `chaves`.  
Exemplo:
```{python}
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python'
}

if 'erin' not in favorite_languages.keys():
  print('Erin, please take our poll!')
```

\newpage

### Percorrendo todas as `chaves` de um dicionário em ordem usando um laço

Um dicionário sempre mantém uma conexão clara entre cada `chave` e seu `valor` associado, mas você não obterá os itens de um dicionário em uma ordem previsível. Isso não é um problema, pois, geralmente, queremos apenas obter o `valor` correto associado a cada `chave`.  
Uma maneira de fazer os itens serem devolvidos em determinada sequência é ordenadar as `chaves` à medida que são devolvidas no laço `for`. Podemos usar a função `sorted()` para obter uma cópia ordenada das chaves.  
Exemplo:
```{python}
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python'
}

for name in sorted(favorite_languages.keys()):
  print(name.title() +
  ", thank you taking the poll.")
```

Essa instrução `for` é como as outras instruções `for`, exeto que a função `sorted()` está em torno do método `dictionary.keys()`. Isso diz a Python para listar todas as `chaves` do dicionário e ordernar essa lista antes de percorrê-la com um laço.

\newpage

### Percorrendo todos os `valores` de um dicionário com um laço

Se você tiver mais interessado nos `valores` contidos em um dicionário, o método `values()` pode ser usado para devolver uma lista de `valores` sem as `chaves`.  
Exemplo:
```{python}
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python'
}
print("The following languages have been mentioned:")
for language in favorite_languages.values():
  print(language.title())
```

A instrução `for`, nesse caso, extrai cada `valor` do dicionário e o armazena na variável `language`.  
Essa abordagem extrai todos os `valores` do dicionário, sem verificar se há repetições. Isso pode funcionar bem com uma quantidade pequena de `valores`, mas em uma enquete com um número grande de entrevistados, o resultado seria uma lista com muitas repetições. Para ver cada linguagem escolhida sem repetições podemos usar um *conjunto* (`set()`). Um conjunto é semelhante a uma lista exceto que cada item de um conjunto deve ser único.  
Exemplo:
```{python}
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python'
}
print("The following languages have been mentioned:")
for language in set(favorite_languages.values()):
  print(language.title())
```

Quando colocamos `set()` em torno de uma lista que contenha itens duplicados, Python identifica os itens únicos na lista e cria um conjunto a partir desses itens. Usamos `set()` para extrair as linguagens únicas em `favorite_languagens.values()`.  
O resultado é uma lista de linguagens mencionadaspelas pessoas que participaram da enquete, sem repetições.

\newpage

## Informações aninhadas

As vezes você vai querer armazenar um conjunto de dicionários em uma lista, uma lista de itens com um valor em um dicionário. Isso é conhecido como **aninhar** informações. podemos aninhar um conjunto de dicionários em uma lista, uma lista de itens em um dicionário ou até mesmo um dicionário em outro dicionário.

### Uma lista de dicionários

É comum armazenar vários dicionários em uma lista quando cada dicionário tiver diversos tipos de informação sobre um o mesmo objeto. Todos os dicionários de uma lista devem ter uma estrutura idêntica para que possamos percorrer a lista com um laço e trabalhar com cada objeto representado por um dicionário do mesmo modo.  
Exemplo:
```{python}
alien_0 = {'color':'green','points':5}
alien_1 = {'color':'yellow','points':10}
alien_2 = {'color':'red','points':15}

aliens = [alien_0,alien_1,alien_2]

for alien in aliens:
    print(alien)
```

Inicialmente criamos três dicionários, cada um representando um alienígena diferente. Reunimos esse dicionários em uma lista chamada `aliens`. Por fim, percorremos a lista com um laço e exibimos cada alien.

\newpage

### Uma lista em um dicionário

Em vez de colocar um dicionário em uma lista, as vezes é conveniente colocar uma lista em um dicionário. Com uma lista armazenada em um dicionário a lista pode ser apenas um dos aspectos do objeto que estamos descrevendo.  
Exemplo:
```{python}
#Armazena informações sobre uma pizza que está sendo pedida
pizza = {'crust':'thick',
          'toppings':['mushrooms','extra cheese']}

#Resumo do pedido
print("You ordered a " +
      pizza['crust'] +
      '-crust pizza ' + 
      "with the following toppings:")
for topping in pizza['toppings']:
  print('\t'+topping)
```

Começamos com um dicionário que armazena informações sobre uma pizza que esta sendo pedida. Uma das `chaves` do dicionário é 'crust', e o `valor` associado é a string 'thick'. A próxima `chave`, 'toppings', tem como `valor` uma lista que armazena todos os ingredientes solicitados. Resumimos o pedido antes de preparar a pizza. Para exibir os ingredientes, escrevemos um laço `for`. Para acessar a lista dos ingredientes, usamos a `chave` 'toppings', e o Python obtém a lista de ingredientes do dicionário.

\newpage

Podemos aninhar uma lista em um dicionário sempre que quisermos que mais de um `valor` seja associado a uma única `chave` em um dicionário. No laço `for` do dicionário, usamos outro laço `for` para percorrer a lista.  
Exemplo:
```{python}
favorite_languages = {
    'jen':['python','ruby'],
    'sarah':['c'],
    'edward':['ruby','go'],
    'phil':['python','haskell']
    }
for name, languages in favorite_languages.items():
    print("\n" + name.title() +
          "'s favorite languages are:")
    for language in languages:
        print("\t" + language.title())
```

Não aninhe listas e dicionários com muitos níveis de profundidade. Se estiver aninhando itens com um nível de profundidade muito maior do que vimos nos exemplos anteriores ou se estiver trabalhando com o código de outra pessoa, e esse código tiver níveis significativos de informações aninhadas, é mais provável que haja uma maneira mais simples de solucionar o problema existente.

\newpage

### Um dicionário em um dicionário

Podemos aninhar um dicionário com outro dicionário, mas o código poderá ficar complicado rapidamente se isso for feito.  
Exemplo:
```{python}
#Dicionário de dicionários
users = {
    'aeinstein':{
        'first':'albert',
        'last':'einstein',
        'location':'princeton'},
    'mcurie':{
        'first':'marie',
        'last':'curie',
        'location':'paris'}
    }

#Extrair informações de um dicionário de dicionários
for username, user_info in users.items():
    print("\nUsername: " + username)
    full_name = user_info['first'] + " " + user_info['last']
    location = user_info['location']
    print("Full name: " + full_name.title())
    print("Location: " + location.title())
```

Ao percorremos o dicionário `users` com um laço, o Python armazena cada `chave` na variável `username` e o dicionário associado a cada nome de usuário (`valor`) na variável `user_info`. Para acessar as informações contida no dicionário `user_info` (`valor`), usamos os métodos normais de acessar informações de um dicionário, lembrando que ele esta contido na variável `user_info`.  
```
location = user_info['location']
```

Observe que a estrutura do dicionário de cada usuário é idêntica. Embora o Python não exija, essa estrutura facilita trabalhar com dicionários aninhados. Se o dicionário de cada pessoa tivesse chaves diferentes, o código no laço `for` seria mais complicado.

\newpage

# Entrada de usuário e laços `while`

A maioria dos programas é escrita para resolver o problema de um usuário final. Para isso, geralmente precisamos obter algumas informações do usuário.   Aprenderemos a aceitar dados de entrada do usuário para que o programa possa então trabalhar com eles. Para tal fim, usaremos a função `input()`.  
O laço `while` do Python mantém o programa executando enquanto determinadas condições permanecem verdadeiras.

## Entrada de usuário - `input()`

### Como a função `input()` trabalha

A função `input()` faz uma pausa em seu programa e espera o usuário fornecer um **texto** (*string*). Depois que o Python recebe a entrada do usuário, esse dado é armazenado em uma variável para que possa ser trabalhado pelo programa, de forma conveniente.  
Exemplo:
```
message = input("Tell me soomething, and I will repeat it back to you: ")
print(message)
```

A função `input()` aceita um argumento: O `prompt` - ou as instruções - que queremos que exiba ao usuário para que eles saibam o que devem fazer. Nesse exemplo, quando Python executar a primeira linha, o usuário verá o `prompt` "*Tell me soomething, and I will repeat it back to you: *". O programa espera enquanto o usuário fornece sua resposta e continua depois que ele teclar **ENTER**. A resposta é armazenada na variável `message`.

O programa **Sublime Text** não executa programas que pedem uma entrada ao usuário. Você pode usar o **Sublime Text** para escrever programas que solicitem uma entrada, mas será necessário executar esses programas a partir de um terminal.  
Exemplo de comando para executar um programa a partir de um terminal:
```
python3 parrot.py
```

\newpage

### Escrevendo `prompts` claros

Sempre que usar a função `input()`, inclua um `prompt` claro, fácil de compreender, que informe o usuário exatamente que tipo de informação ele deve passar. Qualquer frase que diga aos usuários o que eles devem fornecer será apropriada.  
Exemplo:
```
name = input("Please enter your name: ")
print("Hello, " + name.title() + "!")
```

Acrescente um espaço no final de seus `prompts` (depois dos dois-pontos) para separar o `prompt` da resposta do usuário e deixar claro em que lugar o usuário deve fornecer seu texto.  
Ás vezes, você vai querer um `prompt` que seja maior que uma linha. Por exemplo, talvez você queira explicar ao usuário por que está pedindo determinada entrada. Você pode armazenar seu `prompt` em uma variável e passá-la para a função `input()`. Isso permite criar seu `prompt` com várias linhas e escrever uma instrução `input()` clara.  
Exemplo:
```
prompt = "If you tell us who you are, we can personalize the messages you see."
prompt += "\nWhat is your name? "
name = input(prompt)
print("Hello, "+name.title()+"!")
```

Esse exemplo mostra uma maneira de criar uma *string* multilinha. A primeira linha armazena a parte inicial da mensagem na variável `prompt`. Na segunda linha, o operador `+=` acrescenta a nova *string* no final da *string* que estava armazenada em `prompt`.

\newpage

### Usando `int()` para aceitar entradas numéricas

Se usarmos a função `input()`, o Python interpretará tudo que o usuário fornecer como uma *string*.  
Exemplo:
```
age = input("How old are you? ")
age
```

Sabemos que o Python interpretou a entrada como uma string porque o número agora está entre aspas, se tentar usar a entrada como um número, obterá um erro.

Podemos resolver esse problema usando a função `int()`, que diz ao Python para tratar a entrada como um valor numérico. A função `int()` converte a representação em *string* de um número em uma representação numérica.
```
age = input("How old are you? ")
age = int(age)
age
```

Quando usar uma entrada numérica para fazer cálculos e comparações, lembre-se de converter o valor da entrada em uma representação numérica antes.

### Aceitando entradas em Python 2.7

Se você usa Python 2.7, utilize a função `raw_input()` quando pedir uma entrada ao usuário. Essa função interpreta todas as entradas como uma *string*, como faz `input()` em Python 3.  
Python 2.7 também tem uma função `input()`, mas essa função interpreta a entrada do usuário como código Python e tenta executá-la. No melhor caso, você verá um erro informando que Python não é capaz de compreender a entrada; no pior caso, executará um código que não pretendia executar. Se tiver usando Python 2.7, utilize `raw_input()` no lugar de `input()`.

\newpage

## Laço `while`

O laço `for` toma uma coleção de itens e executa um bloco de código uma vez para cada item da coleção. Em comparação, o laço `while` executa durante o tempo em que, ou enquanto, uma determinada condição for verdadeira.

### Laço `while` em ação

Podemos usar um laço `while` para contar uma série de números.
Exemplo:
```{python}
current_number = 1
while current_number <= 5:
    print(current_number)
    current_number += 1
```

O laço `while` é configurado para continuar executando enquanto o valor de `current_number` for menor ou igual a 5. O código no laço exibe o valor `current_number` e então é somado 1 a esse valor com `current_number += 1`. (O operador `+=` é um atalho para `current_number = current_number + 1`)  
O Python repete o laço enquanto a condição `current_number <= 5` for verdadeira.

Os programas que você usa no dia a dia provavelmente contêm laços `while`. Por exemplo, um jogo precisa de um laço `while` para continuar executando enquanto você quiser jogar, e pode parar de executar assim que você pedir para sair.

\newpage

### Deixando usuário decidir quando quer sair

Definimos um valor de saída e então deixamos o programa executando enquanto o usuário não tiver fornecido o valor de saída.  
Exemplo:
```
prompt = "\nTell me soomething, and I will repeat it back to you:"
prompt += "\n(Enter 'quit' to end the program.)"
prompt += "\n"

message = ""
while message != 'quit':
    message = input(prompt)
    if message != 'quit': #Não repete o 'quit'
        print(message)
```

Primeiro definimos um `prompt` que informa quais são as duas opções ao usuário: fornecer uma mensagem ou o valor de saída (nesse caso, é 'quit'). Em seguida, preparamos uma variável `message` para armazenar o valor que o usuário forneceu. Definimos `message` como uma string vazia, "", de modo que o Python tenha algo para conferir na primeira vez quealcançar a linha com `while`. Na primeira vez que o programa executar e o Python alcançar a instrução `while`, ele deverá comparar o valor de `message` com 'quit', mas o usuário não forneceu nenhuma entrada.  
Se o Python não tiver nada para comparar, ele não será capaz de continar executando o programa. Para resolver esse problema, garantimos que `message` receba algum valor inicial. Embora seja apenas uma *string* vazia, ela fará sentido para o Python e permitirá que a comparação que faz o laço `while` funcionar seja feita. Esse laço `while` executa enquanto o valor de `message` não for 'quit'.  
Desde que o usuário não tenha fornecido a palavra 'quit', o `prompt` será exibido novamente e o Python esperará mais entradas. Quando o usuário finalmente digitar 'quit', o Python para de executar o laço `while` e o programa termina.

\newpage

### Usando uma flag

No exemplo anterior, tinhamos um programa que executava determinada tarefa enquanto uma dada condição era verdadeira. E como ficaria em programas mais complicados emque muitos eventos diferentes poderiam fazer o programa parar de executar?  
Se muitos eventos possíveis puderem ocorrer para o programa terminar, tentar testar todas essas condições em uma única instrução `while` torna-se complicado e difícil.  
Para um programa que deva executar somente enquanto muitas condições forem verdadeiras, podemos definir uma variável que determina se o programa como um todo deve estar ativo. Essa variável, chamada `flag`, atua como um sinal para o programa. Podemos escrever nossos programas de modo que executem enquanto a `flag` estiver definida como `True` e parem de executar quando qualquer um dos vários eventos definir o valor da `flag` como `False`. Como resultado, nossa instrução `while` geral precisa verificar apenas uma condição: se a `flag`, no momento, é `True`. Então todos nossos demais testes (para ver se um evento que deve definir a `flag` como `False` ocorreu) podem estar bem organizados no restante do programa.  
Exemplo:
```
prompt = "\nTell me soomething, and I will repeat it back to you:"
prompt += "\n(Enter 'quit' to end the program.)"
prompt += "\n"

active = True

message = ""
while active:
    message = input(prompt)
    if message == 'quit':
        active = False
    else:
        print(message)
```

Definimos a variável `active` como `True` para que o programa comece em um estado ativo. Fazer isso simplifica a instrução `while`, pois nenhuma comparação é feita nessa instrução; a lógica é tratada em outras partes do programa. Enquanto a variável `active` permanecer `True`, o laço continuará a executar.  
Se o usuário fornecer 'quit', definimos `active` como `False` e o laço `while` é encerrado. Se o usuário fornecer outro dado que não seja 'quit', exibimos essa entrada como uma mensagem.  
Esse programa gera a mesma saída do exemplo anterior, em que havíamos colocado o teste condicional diretamente na instrução `while`. Porém, agora que temos uma `flag` para inidicar se o programa como um todo está em um estado ativo, será mais fácil acrescentar outros testes (por exemplo, instruções `elif`) para eventos que devam fazer `active` se tornar `False`. Isso é útil em programas complicados, como jogos, em que pode haver muitos eventos, e qualquer um deles poderia fazer o programa parar de executar. Quando um desses eventos fizer a `flag` `active` se tornar `False`, o laço principal do jogo terminará, uma mensagem de *Game Over* poderia ser exibida e o jogador poderia ter a opção de jogar novamente.

### Usando `break` para sair de um laço

Para sair de uma laço `while` de imediato, sem executar qualquer código restante no laço, independente do resultado de qualquer teste condicional, utilize a instrução `break`.  
Exemplo:
```
prompt = "\nPlease enter the name of a city you have visited:"
prompt += "\n(Enter 'quit' when you are finished.)"
prompt += "\n"

while True:
    city = input(prompt)
    
    if city == 'quit':
        break
    else:
        print("I'd love to go to " + 
              city.title() + "!")
```

Um laço que comece com `while` `True` executará indefinidamente, a menos que alcance uma instrução `break`. O laço desse programa continuará pedindo aos usuários para que entrem com os nomes das cidades em que eles estiveram até que 'quit' seja fornecido. Quando 'quit' for digitado, a instrução `break` é executada, fazendo o Python sair do laço.

Você pode usar a instrução `break` em qualquer laço do Python. Por exemplo, `break` pode ser usado para sair de um laço `for` que esteja percorrendo uma lista ou um dicionário.

\newpage

### Usando `continue` em um laço

Em vez de sair totalmente de um laço sem executar o restante de seu código podemos usar a instrução `continue` para retornar ao início, com base no resultado de um teste condicional.
Exemplo:
```{python}
current_number = 0
while current_number < 10:
    current_number += 1
    if (current_number % 2) == 0: #Se for par
        continue
    print(current_number)
```

No laço conta de 1 a 10, mas apresenta apenas os números impares desse intervalo.  
Se o módulo for 0 (o que significa que current_number é divisível por 2), a instrução `continue` diz ao Python para ignorar o restante do laço e voltar ao início. Se o número atual não for divisível por 2, o restante do laço será executado e o Python exibirá o número atual.

### Evitando loops infinitos

Todo laço `while` precisa de uma maneira de interromper a execução para que não continue executando indefinidademente.  
Exemplo:
```
x = 1
while x <= 5 :
    print(x)
    #x += 1
```

Se for omitida a linha `x += 1` por acidente, o laço executará para sempre.  
Agora o valor de x começará em 1, mas jamais será modificado. Como resultado, o teste condicional `x <= 5` será sempre avaliado como `True` e o laço `while` executará indefinidamente, exibindo uma série de 1s.

Todo programador escreve ocasionalmente um loop infinito (ou laço infinito) com `while` por acidente, em especial quando os laços do programa tiverem condições de saída sutis. Se o programa ficar preso em um loop infinito, tecle `CTRL-C` ou simplesmente feche a janela do terminal que está exibindo a saída de seu programa.  
Para evitar escrever loops infinitos, teste todos os laços `while` e certifique-se de que eles serão encerrados conforme esperado. Se quiser que seu programa termine quando o usuário fornecer determinado valor de entrada, analise cuidadosamente o modo como seu tratará o valor que deveria fazer o laço parar. Garanta que pelo menos uma parte do programa possa fazer a condição do laço ser `False` ou fazer uma instrução `break` ser alcançada.

Alguns editores, como o Sublime Text, tem uma janela de saída incluida. Isso pode dificultar a interrupção de um loop infinito, e talvez seja necessário fechar o editor para encerrar o laço.

\newpage

## Usando um laço `while` com listas e dicionários

Para controlar muitos usuários e informações, precisamos usar listas e dicionários com os laço `while`.  
Um laço `for` é eficiente para percorrer uma lista, mas você não deve modificiar uma lista em um laço `for`, pois o Python terá problemas para manter o controle dos itens da lista. Para modificar uma lista enquanto trabalha com ela, utilize um laço `while`. Usar laços `while` com listas e dicionários permite coletar, armazenar e organizar muitas entradas a fim de analisá-las e apresentá-las posteriormente.

### Transferindo itens de uma lista para outra

Uma maneira de transferir itens de uma lista para outra lista seria usar um laço `while`, a medida que os dados são trabalhados são transferidos de uma lista para outra.  
Exemplo:
```{python}
#Transferindo itens de uma lista para outra, usando while

unconfirmed_users = ["alice","brian","candace"]
confirmed_users = []

while unconfirmed_users: #O laço continuar enquanto a lista não for vazia
    current_user = unconfirmed_users.pop() #pesca o ultimo item da lista
    
    print("Verifying user: " + current_user.title())
    confirmed_users.append(current_user) #Adiciona o item na lista
print("\nThe following users have been confirmed:")
for confirmed in confirmed_users:
    print(confirmed.title())
```

O laço `while` é executado enquanto a lista `unconfirmed_users` não tiver vazia. Nesse laço, o método `.pop()` remove os usuários não verificados, um de cada vez, do final de `unconfirmed_users`. Nesse caso, como Candace é o último elemento da lista `unconfirmed_users`, seu nome será o primeiro a ser removido, armazenado em `current_user` e adicionado a lista `confirmed_users`. O próximo é Brian e, depois, Alice.

### Removendo todas as instâncias de valores específicos de uma lista

Usamos `remove()` para remover umvalor específico de uma lista. A função `remove()` era apropriada porque o valor em que estávamos interessados aparecia apenas uma vez na lista. Porém, e se quiséssemos remover da lista todas as instâncias de um valor?  
Suponha que tenhamos uma lista de animais de estimação com o valor 'cat' repetido várias vezes, e desejamos remover todos os 'cat'.  
Exemplo:
```{python}
#Removendo todas as instâncias de valores especificos de uma lista

pets = ["dog","cat","dog","goldfish","cat","rabbit","cat"] #Lista
print(pets)

while 'cat' in pets: #Enquanto 'cat' contido na lista pets faça:
    pets.remove('cat') #Remove o primeiro 'cat' que aparecer, a cada iteração

print(pets) #Nova lista
```

Começamos com uma lista contendo várias instâncias de 'cat'. Após exibir a lista, o Python entra no laço `while`, pois encontra o valor 'cat' na lista pelo menos uma vez. Depois que entrar no laço, o Python remove a primeira instância de 'cat', retorna para a linha `while` e então entra novamente no laço quando descobre que 'cat' ainda existe na lista. Cada instância de 'cat' é removida até que o valor não esteja mais na lista; nesse momento, o Python sai do laço e exibe a lista novamente.

\newpage

### Preenchendo um dicionário com dados de entrada do usuário

Podemos pedir a quantidade de entrada que for necessária a cada passagem por um laço `while`. Armazenamos os dados coletados em um dicionário.  
Exemplo:
```
#Preenchendo um dicionário com dados de entrada e saída

#Inicializando um dicionário vazio
responses = {}

#Flag
polling_active = True

while polling_active:
    #Pede o nome da pessoa e a resposta
    name = input("\nWhat's your name? ")
    response = input("Which mountain would you to climb someday? ")
    
    #Armazenando resposta no dicionári,o name como chave e response como valor.
    responses[name] = response
    
    #Criterio de saída do laço, ou nova enquete
    repeat = input("Would you like to let another person respond? (yes/no) ")
    if repeat == 'no':
        polling_active = False

#Percorrendo o dicionário
#Enquete concluída, mostra o resultado
print("\n--- Poll Results ---")
for name, response in responses.items():
    print(name.title() + " would like to climb " + response + ".")
```

O programa inicialmente define um dicionário vazio (`responses`) e cria uma `flag` (`polling_active`) para indicar que a enquete esta ativa. Enquanto `polling_active` for `True`, o Python executará o código que está no laço `while`.  
Nesse laço é solicitado ao usuário que entre com seu nome e montanha que gostaria de escalar. Essa informação é armazenada no dicionário `responses` (nome é a `chave` e resposta é `valor` relacionado a `chave`), e uma pergunta é feita ao usuário para saber se ele quer que a enquete continue. Se o usuário responder 'yes', o programa entrará no laço `while` novamente. Se responder 'no', a `flag` `polling_active` será definida como `False`, o laço `while` para de executar e o último bloco de código exibe o resultado da enquete.

\newpage

# Funções

Funções, que são blocos de código nomeados, concebidos para realizar uma tarefa específica. Quando queremos executar uma tarefa em particular, definida em um função, chamamos o nome da função responsável por ela. Se precisar executar essa tarefa várias vezes durante seu programa, não será necessário digitar todo o código para a mesma tarefa repetidamente, basta chamar a função dedicada ao tratamento dessa tarefa e a chamada dirá ao Python para executar o código da função.  
sobre as maneiras de passar informações as funções, escrevemos determinadas funções cuja tarefa principal seja exibir informações e outras funções que visam a processar dados e devolver um valor ou um conjunto de valores. Veremos como armazenar funções em arquivos separados, chamados de *módulos*, para ajudar a organizar os arquivos principais de seu programa.

## Definindo uma função

Sintaxe:
```
def nome_funcao (parâmetro_1,...):
    """docstrig"""
    bloco de programação

nome_funcao(argumento_1,...)
```

Exemplo:
```{python}
def greet_user(): #Define o nome e parâmetros da função
    """Exibe um saudação simples.""" #Docstring
    print("Hello world!") #Bloco de programação

greet_user() #Chama a função
```

Esse exemplo mostra a estrutura mais simples possível para uma função. A primeira linha utiliza a palavra `def` para informar ao Python que estamos definindo uma função. Essa é a definição da função, que informa o nome da função ao Python e, se for aplicável, quais os tipos de informação necessários a função para que ela faça sua tarefa (parâmetros). Os parênteses contêm essa informação. Nesse caso, o nome da função é `greet_user()`, e ela não precisa de nenhuma informação para executar sua tarefa, portanto os parênteses estão vazios. (Mesmo assim, eles são obrigatórios.) Por fim, a definição termina com dois-pontos.  
Qualquer linha indentada após `def greet_user():` faz parte do corpo da função. O texto na segunda linha é um comentário chamado `docstring`, que descreve o que a função faz. As `docstring` são colocadas entre aspas triplas, que o Python procura quando gera a documentação das funções de seus programas.  
Quando quiser usar essa função, você deve chamá-la. Uma chamada de função diz ao Python para executar o código da função. Para chamar a função, escreva o nome dela, seguido de qualquer informação necessária entre parênteses (argumentos, se for o caso).

### Passando informação para uma função

Muitas vezes para que a função faça algo é necessário que especifique um parâmetro, entre os parênteses, da definição da função em `def greet_users()`.  
Ao definir um parâmetro, permitimos que a função aceite qualquer valor que você especificar como parâmetro. A função agora espera que um valor seja fornecido para variável parametro sempre que ela for chamada. Ao chamar `greet_user()`, você poderá lhe passar um nome, por exemplo, 'jesse', entre parênteses.  
Exemplo:
```{python}
def greet_user(username): #Define o nome e parâmetros da função
    """Exibe um saudação simples.""" #Docstring
    print("Hello " + username.title() + "!") #Bloco de programação

greet_user('jesse') #Chama a função e passa um argumento
```

### Argumentos e parâmetros

A variável `username` na definição da função `greet_user()` (exemplo anterior) é um exemplo de *parâmetro*, uma informação de que a função precisa para executar sua tarefa. O valor 'jesse' em `greet_user('jesse')` é um exemplo de *argumento*. Um argumento é uma informação passada para uma função em sua chamada. Quando chamamos a função, colocamos entre parênteses o valor com que queremos que a função trabalhe. Nesse caso, o argumento 'jesse' foi passado para a função `greet_user()` e o valor foi armazenado no parâmetro `username`.  
As vezes, as pessoas falam de argumentos e parâmetros de modo indistinto. Não fique surpreso se vir as variáveis de uma definição de função serem referenciadas como argumentos, ou as variáveis de uma chamada de função serem chamadas de parâmetros.

\newpage

## Passando argumentos

Pelo fato de ser possível que uma definição de função tenha vários parâmetros, uma chamada de função pode precisar de diversos argumentos. Os argumentos podem ser passados para as funções de várias maneiras. Podemos usar *argumentos posicionais*, que devem estar na mesma ordem em que os parâmetros foram escritos, *argumentos nomeados* (keyword arguments), em que cada argumento é constituído de um nome de variável e de um valor, ou por meio de listas e dicionários de valores.

### Argumentos posicionais

Quando chamamos uma função, o Python precisa fazer a correspondência entre cada argumento da chamada da função e um parâmetro da definição. A maneira mais simples de fazer isso é contar com a ordem dos argumentos fornecidos. Valores cuja correspondência seja feita dessa maneira são chamados de *argumentos posicionais*.  
Exemplo:
```{python}
def describe_pet(animal_type, pet_name):
    """Exibe informações sobre um animal de estimação."""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")
    
describe_pet('hamster', "harry") #Argumento posicional
```

A definição mostra que essa função precisa de um tipo de animal e de seu nome. Quando chamamos `describe_pet()`, devemos fornecer o tipo de animal e um nome, nessa ordem. Por exemplo, na chamada da função, o argumento 'hamster' é armazenada no parâmetro `animal_type` e o argumento 'harry' é armazenado no parâmetro `pet_name`.

\newpage

### Várias chamadas de função

Podemos chamar uma função quantas vezes forem necessárias.  
Exemplo:
```{python}
def describe_pet(animal_type, pet_name):
    """Exibe informações sobre um animal de estimação."""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")
    
describe_pet('hamster', "harry") #Argumento posicional
describe_pet('dog', "willie") #Várias chamadas de função
```

Nessa segunda chamada da função, passamos os argumentos 'dog' e 'willie' a `describe_pet()`. Assim como no conjunto anterior de argumentos que usamos, o Python faz a correspondência entre 'dog' e o parâmetro `animal_type` e entre 'willie' e o parâmetro `pet_name`. Como antes, a função faz sua tarefa, porém, dessa vez, exibe valores para um cachorro chamado Willie. Agora temos um hamster chamado Herry e um cachorro chamado Willie.  
Chamar uma função várias vezes é uma maneira eficiente de trabalhar. O código que descreve um animal de estimação é escrito uma só vez na função. Então, sempre que quiser descrever um novo animal de estimação, podemos chamar a função com as informações sobre o animal. Mesmo que o código para descrever um animal de estimação fosse expandido atingindo dez linhas, poderíamos ainda descrever um novo animal de estimação chamando a função novamente com apenas uma linha.  
Podemos usar tantos argumentos pasicionais quantos forem necessários nas funções. O Python trabalha com os argumentos fornecidos na chamada da função e faz a correspondência de cada um com o parâmetro associado na definição da função.

\newpage

### A ordem é importante em argumentos posicionais

Podemos obter resultados inesperados se confundirmos a ordem dos argumentos em uma chamada de função quando argumentos posicionais forem usados.  
Exemplo:
```{python}
def describe_pet(animal_type, pet_name):
    """Exibe informações sobre um animal de estimação."""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")
    
describe_pet('harry', 'hamster') #Argumento posicional errado
```

Se obtivermos resutados engraçados, verifique se a ordem dos argumentos em sua chamada de função corresponde à ordem dos parâmetros na definição da função.

### Argumentos nomeados

Um *argumento nomeado* (keyword argument) é um par nome-valor passado para uma função. Associamos diretamente o nome e o valor no próprio argumento para que não haja confusão quando ele for passado para a função. Argumentos nomeados fazem com que você não precise se preocupar com a ordem correta de seus argumentos na chamada da função e deixam claro o papel de cada valor na chamada.  
Exemplo:
```{python}
def describe_pet(animal_type, pet_name):
    """Exibe informações sobre um animal de estimação."""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet(animal_type="hamster", pet_name="harry") #Argumentos nomeados
```

Quando chamamos a função, dizemos explicitamente ao Python a qual parâmetro cada argumento deve corresponder. Quando o Python lê a chamada da função, ele sabe que deve armazenar o argumento 'hamster' no parâmetro `animal_type` e o argumento 'harry' em `pet_name`.  
A ordem dos argumentos nomeados não importa, pois o Python sabe o que é cada valor.  

Quando usar argumentos nomeados, lembre-se de usar os nomes exatos dos parâmetros usados na definição da função.

### Valores default

Ao escrever uma função, podemos definir um valor *default* para cada parâmetro. Se um argumento para um parâmetro for especificado na chamada da função, o Python usará o valor desse argumento. Se não for, o valor *default* do parâmetro será utilizado. Portanto, se um valor *default* for definido para um parâmetro, você poderá excluir o argumento correspondente, que normalmente seria especificado na chamada da função. Usar valores *default* pode simplificar suas chamadas de função e deixar mais claro o modo como suas funções normalmente são utilizadas.  
Exemplo:
```{python}
def describe_pet(pet_name,animal_type='dog'): #Definindo default
    """Exibe informações sobre um animal de estimação."""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet(pet_name="willie")
```

Mudamos a definição de `describe_pet()` para incluir um valor default igual a 'dog' para `animal_type`. A partir de agora, quando a função for chamada sem um `animal_type` especificado, o Python saberá que deve usar o valor 'dog' para esse parâmetro.  
Observe que a ordem dos parâmetros na definição da função precisou ser alterada. Como o uso do valor default faz com que não seja necessário especificar o tipo de animal como argumento, o único argumento restante na chamada da função é o nome do animal de estimação. O Python continua interpretando esse valor como um argumento posicional, portanto, se a função for chamda somente com o nome do animal de estimação, esse argumento corresponderá ao primeiro parâmetro listado na definição da função. Esse é o motivo pelo qual o primeiro parâmetro deve ser `pet_name`.  
Quando um argumento explicito para `animal_type` for especificado, o Python ignorará o valor default do parâmetro.

Ao usar valores default, qualquer parâmetro com um valor desse tipo deverá ser listado após todos os parâmetros que não tenham valores default. Isso permite que o Python continue a interpretar os argumentos posicionais corretamente.

### Chamadas de função equivalente

Como os argumentos posicionais, os argumentos nomeados e os valores default podem ser usados em conjunto, e com frequência você terá várias maneiras equivalentes de chamar uma função.  
```
def describe_pet(pet_name,animal_type='dog'):
```
Com essa definição, um argumento sempre deverá ser fornecido para `pet_name` e esse valor pode ser especificado por meio do formato posicional ou nomeado.  
Todas as chamadas a seguir serão adequadas a essa função:  
```
#Um cachorro chamado willie
describe_pet('willie')
describe_pet(pet_name='willie')

#Um hamster chamado harry
describe_pet('harry','hamster')
describe_pet(pet_name='harry',animal_type='hamster')
describe_pet(animal_type='hamster',pet_name='harry')
```
Cada uma dessas chamadas de função produzirá a mesma saída.

O estilo de chamada que você usar relamente não importa. Desde que suas chamadas de função gerem a saída desejada, basta usar o estilo que achar mais fácil de entender.

### Evitando erros em argumentos

Quando começar a usar funções, não se surpreenda se você se deparar com erros sobre argumentos sem correspondência. Argumentos sem correspondência ocorrem quando fornecemos menos ou mais argumentos necessários à função para que ela realize sua tarefa.

\newpage

## Valores de retorno

Uma função nem sempre precisa exibir sua saída diretamente. Em vez disso, ela pode processar alguns dados e então devolver um valor ou um conjunto de valores. O valor devolvido pela função é chamado de *valor de retorno*. A instrução `return` toma um valor que esta em uma função e o envia de volta a linha que a chamou. Valores de retorno permitem passar boa parte do trabalho pesado de um programa para funções, o que pode simplificar o corpo do programa.

### Devolvendo um valor simples

Exemplo:
```{python}
def get_formatted_name(first_name,last_name):
    """Devolve um nome completo formatado de modo elegante."""
    full_name = first_name + " " + last_name
    return full_name.title() #Retorna valor da função

musician = get_formatted_name('jimi', 'hendrix')
print(musician)
```

A definição `get_formatted_name()` aceita um primeiro nome e um sobrenome como parâmetros. A função combina esses dois nomes, acrescenta um espaço entre eles e armazena o resultado na variável `full_name`. O valor `full_name` é convertido para que tenha letras iniciais maiúsculas e é devolvido para a linha que fez a chamada.  
Quando chamamos uma função que devolve um valor, precisamos fornecer uma variável em que o valor de retorno possa ser armazenada. Nesse caso, o valor devolvido é armazenado na variável `musician`.

\newpage

### Deixando um argumento opcional

As vezes faz sentido criar um argumento opcional para que as pessoas que usarem a função possam optar por fornecer informações extras somente se quiserem. Valores default podem ser usados para deixar um argumento opcional.  
Exemplo:
```{python}
def get_formatted_name(first_name,last_name,middle_name=''): #add parâmetro opcional
    """Devolve um nome completo formatado de modo elegante."""
    if middle_name: #middle_name vazio é false (else), e com algo é true (if)
        full_name = first_name + " " + middle_name + " " + last_name
    else:
        full_name = first_name + " " + last_name
    return full_name.title() #Retorna valor da função

musician = get_formatted_name('john', 'hooker','lee')
print(musician)
```

Os nomes do meio nem sempre são necessários. Para deixar o nome do meio opcional, podemos associar um valor default vazio ao argumento `middle_name` e ignorá-lo, a menos que o usuário forneça um valor. Para que `get_formatted_name()` funcione sem um nome do meio, definimos o valor default de `middle_name` como uma string vazia e o passamos para o final da lista de parâmetros.  
Nesse exemplo, o nome é criado a partir de três partes possíveis. Como o primeiro nome e o sobrenome sempre existem, esses parâmetros são listados antes na definição da função. O nome do meio é opcional, portanto é listado por último na definição, e o seu valor default é uma string vazia.  
No corpo da função verificamos se o nome do meio foi especificado. O Python interpreta strings não vazias como `True`, portanto `if middle_name` será avaliado como `True` se o argumento para o nome do meio estiver na chamada da função. Se um nome do meio for especificado, o primeiro nome, o nome do meio, e o sobrenome serão combinados para compor um nome completo. Esse nome é então alterado para que as iniciais sejam maiúsculas e é devolvido para linha que chamou a função: ele será armazenado em uma variável `musician` e exibido. Se o nome do meio não for especificado, a string vazia falhará no teste `if` e o bloco `else` será executado. O nome completo será composto apenas do primeiro nome e o sobrenome, e o nome formatado é devolvido para a linha que fez a chamada: ele será armazenado em `musician` e exibido.  
Valores opcionais permitem que as funções tratem uma grande variedade de casos de uso, ao mesmo tempo que simplifica ao maxímo as chamadas de função.

\newpage

### Devolvendo um dicionário

Uma função pode devolver qualquer tipo de valor necessário, incluindo estruturas de dados mais complexas como listas e dicionários.  
Exemplo:
```{python}
def build_person(first_name,last_name,age=''):
    """Devolve um dicionário com informações sobre uma pessoa."""
    person = {'first':first_name,'last':last_name}
    if age: #Se age não vazio, então True, logo adiciona ao dicionário
        person['age']=age
    return person

musician = build_person('jimi', 'hendrix',age=27)
print(musician)
```

A função `build_person()` aceita um primeiro nome e um sobrenome e então reúne esses valores num dicionário. O valor `first_name` é armazenado com a chave `first` e o valor de `last_name` é armazenado com a chave `last`. O valor de retorno com duas informações textuais originais agora armazenadas em um dicionário.  
Essa função aceita informações textuais simples e as coloca em uma estrutura de dados mais significativa, que permite trabalhar com as informações além de simplesmente exibi-las.  
É adicionado um novo parâmetro opcional `age` a definição de função e atribuido um valor default vazio ao parâmetro. Se a chamada da função incluir um valor para esse parâmetro, ele será armazenado no dicionário. Essa função sempre armazena o nome de uma pessoa, mas também pode ser modificada para guardar outras informações que você quiser sobre ela.

\newpage

### Usando uma função com um laço `while`

Podemos usar funções com todas as estruturas Python que conhecemos até agora. Por exemplo, vamos usar a funçao `get_formatted_name()` com um laço `while` para saudar os usuários de modo mais formal.  
```
def get_formatted_name(first_name,last_name):
    """Devolve um nome completo formatado de modo elegante."""
    full_name = first_name + " " + last_name
    return full_name.title()

while True:
    print("\nPlaese tell me your name? ")
    print("(Enter 'q' at any time to quit)")
    f_name = input("First name: ")
    if f_name == "q":
        break
    l_name = input("Last name: ")
    if l_name == "q":
        break
    formatted_name = get_formatted_name(f_name, l_name)
    print("\nHello, " + formatted_name + "!")
```

Adicionamos uma mensagem que informa como o usuário pode sair e então encerramos o laço se o usuário fornecer o valor de saída em qualquer um dos `prompts`. Agora o programa continuará saudando as pessoas até que alguém forneça 'q' em algum dos nomes.

\newpage

## Passando uma lista para uma função

Com frequência, você achará útil passar uma lista para uma função, seja uma lista de nomes, de números ou de objetos mais complexos, como dicionários. Se passarmos uma lista a uma função, ela terá acesso direto ao conteúdo dessa lista.  
Exemplo:
```{python}
def greet_users(names):
    """Exibe uma saudação simples a cada usuário da lista."""
    for name in names:
        print("Hello, " + name.title() + "!")

usernames = ['hannah', 'ty', 'margot']
greet_users(usernames)
```

Definimos `greet_users()` para que espere uma lista de nomes, que é armazenada no parâmetro `names`. A função percorre a lista recebida com um laço e exibe uma saudação para cada usuário. Definimos uma lista de usuários e então passamos a lista `usernames` para `greet_users()` em nossa chamada de função.

### Modificando uma lista em uma função

Quando passamos uma lista a uma função, ela pode ser modificada. Qualquer alteração feita na lista no corpo da função é permanente, permitindo trabalhar de modo eficiente, mesmo quando lidamos com grandes quantidades de dados.(Ver **escopo de variável**, sub-tópico).

\newpage

Exemplo de programa sem funções, trabalhando com listas:
```{python}
#Sem função, trabalhando com listas

#Começa com alguns designs que devem ser impressos.
unprinted_designs = ['iphone case','robot pendant','dodecahedron']
completed_models = []

#Simula a impressão de cada design, até que não haja mais nenhum
#Transfere cada design para completed_models após a impressão
while unprinted_designs:
    current_design = unprinted_designs.pop()
    
    #Simula a criação de uma impressão 3D a partir do design
    print("Printing model: " + current_design)
    completed_models.append(current_design)
    
#Exibe todos os modelos finalizados
print("\nThe following models have been printed:")
for complet_model in completed_models:
    print(complet_model)
```

\newpage

Exemplo de funções trabalhando com listas:
```{python}
def print_models(unprinted_designs, completed_models):
    """
    Simula a impressão de cada design, até que não haja mais nenhum.
    transfere cada design para completed_models após a impressão.
    """
    while unprinted_designs: #Enquanto a lista não for vazia o loop continua
        current_design = unprinted_designs.pop()
        
        #Simula a criação de uma impressão 3D a partir do design
        print("Printing model: " + current_design)
        completed_models.append(current_design)

def show_completed_models(completed_models):
    """Exibe todos os modelos finalizados"""
    print("\nThe following models have been printed:")
    for complet_model in completed_models: #Percorre a lista
        print(complet_model)
    
#Alguns designs que devem ser impressos.
unprinted_designs = ['iphone case','robot pendant','dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
```

Definimos a função `print_models()` com dois parâmetros: uma lista de designs a serem impressos e uma lista de modelos concluídos. Dadas essas duas listas, a função simula a impressão de cada design esvaziando a lista de designs não impressos e preenchendo a lista de designs completos. Também definimos a função `show_completed_models()` com um parâmetro: a lista de modelos finalizados. Dada essa lista, `show_completed_models()` exibe o nome de cada modelo impresso.

Esse exemplo também mostra a ideia de que toda função deve ter uma tarefa específica. A primeira função imprime cada design, enquanto a segunda mostra os modelos concluídos. Isso é mais vantajoso que usar uma única função para executar as duas tarefas. Se você estiver escrevendo uma função e perceber que ela esta fazendo muitas tarefas diferentes, experimente dividir o código em duas funções. Lembre-se de que você sempre pode chamar uma função a partir de outras funções, o que pode ser conveniente quando dividimos uma tarefa complexa em uma série de passos.

#### Variável

Uma variável é um rótulo ou um nome dado a um determinado local na memória. Esse local contém o valor que você deseja que o programa memorize, para uso posterior. O que é ótimo em Python é que você não precisa declarar explicitamente qual é o tipo de variável que deseja definir.

O Python tem algumas regras que você deve seguir ao criar uma variável:

  1. Ele só pode conter letras (maiúsculas ou minúsculas), números ou o caractere de sublinhado "_".
  2. Ele pode não começar com um número.
  3. Pode não ser uma palavra-chave (você aprenderá sobre elas mais adiante).

#### Escopo de variável

É o limite das variáveis em um programa - seu "escopo". Os quatro escopos diferentes são: **local**, **envolvente**, **global** e **incorporado**.  
  
  1. Local:  
   Sempre que você definir uma variável em uma função, seu escopo estará somente dentro da função. Ele pode ser acessado do ponto em que é definido até o final da função e existe enquanto a função estiver sendo executada. Isso significa que seu valor não pode ser alterado ou mesmo acessado de fora da função.
  
  2. Global:  
   Esse talvez seja o escopo mais fácil de entender. Sempre que uma variável é definida fora de qualquer função, ela se torna uma variável global, e seu escopo é qualquer lugar dentro do programa. Isso significa que ele pode ser usado por qualquer função.

Também podemos associar na variável um parâmetro que muda a propriedade da variável.  
  
  1. `global` - torna a variável global:  
   `global nome_variável`

  2. `local` - torna a variável local:  
   `local nome_variável`

\newpage

### Evitando que uma função modifique uma lista

As vezes você vai querer evitar que uma função modifique uma lista. 
Por exemplo, suponha que você comece com uma lista de designer não impressos e 
escreva uma função que transfira esses designs para uma lista de modelos terminados,
como no exemplo anterior. Talvez você decida que, apesar de ter imprimido todos os designs, 
vai querer manter a lista original de designs não impressos em seus registros. 
Porém, como você transferiu todos os nomes de designs de `unprinted_designs`, 
a lista agora esta vazia, e essa é a única versão da lista que você tem; a lista original se perdeu. 
Nesse caso, podemos tratar esse problema passando uma cópia da lista para a função, 
e não a lista original. Qualquer alteração que a função fizer na lista 
afetará apenas a cópia, deixando a lista original intacta.  

Enviando uma cópia de uma lista para uma função:  
`nome_da_função(nome_lista[:])` 

A notação de fatia [:] cria uma cópia da lista para ser enviada à função.  
`print_models(unprinted_designs[:], completed_models)`

A função `printed_models()` pode fazer seu trabalho, pois ela continua recebendo 
os nomes de todos os designs não impressos. Porém, dessa vez, ela usa uma cópia 
da lista original de designs não impressos, e não a lista `unprinted_designs` propriamente 
dita. A lista `completed_models` será preenchida com os nomes dos modelos impressos, 
como antes, mas a lista original de designs não impressos não será afetada pela 
função.  
Apesa de poder preservar o conteúdo de uma lista passando uma cópia dela para suas 
funções, você deve passar a lista original para as funções, a menos que 
tenha um motivo específico para passar uma cópia. Para uma função, 
é mais eficiente trabalhar com uma lista existente a fim de evitar o uso de **tempo** 
e de **memória** necessários para criar uma cópia separada, em especíal quando trabalhamos 
com listas grandes.

\newpage

## Passando um número arbitrário de argumentos

As vezes não saberá com antecedência quantos argumentos uma função deve aceitar. Felizmente, 
o Python permite que uma função receba um número arbitrário de argumentos da instrução de chamada.  
Exemplo:
```{python}
def make_pizza(*toppings): #Cria uma tupla para receber número aleatório de argumentos
    """Apresenta a pizza que estamos prestes a preparar."""
    print("\nMaking a pizza with the following toppings:")
    for topping in toppings:
        print(topping)

make_pizza('peperoni')
make_pizza('mushrooms','green peppers','extra cheese')
```

No exemplo tem um parâmetro `*toppings`, mas esse parâmetro agrupa tantos argumentos quantos forem fornecidos na linha de chamada.  
O asterisco no nome do parâmetro `*toppings` diz ao Python para criar uma **tupla vazia** chamada `toppings` e reunir os valores recebidos nessa tupla. A instrução `print` no corpo da função gera uma saída que mostra que o Python é capaz de tratar uma chamada de função com um valor e outra chamada com três valores. As chamadas são tratadas de modo semelhante. Observe que o Python agrupa os argumentos em uma tupla, mesmo que a função receba apenas um valor.

Essa sintaxe funciona, não importa quantos argumentos a função receba.

Tuplas:  
Tuplas são listas em que os itens não são criadas para mudar (listas imutáveis).  
Uma tupla se parece com uma lista, exceto por usar parênteses no lugar de colchetes.  
Sintaxe:
```
tuplas = (valor_1,valor_2,valor_3,...)
```

\newpage

### Misturando argumentos posicionais e arbitrários

Se quiser que uma função aceite vários tipos de argumentos, o parâmetro que aceita um número arbitrário de argumentos deve ser colocado por último na definição da função. O Python faz a correspondência de argumentos posicionais e nomeados antes, e depois agrupa qualquer argumento remanescente no último parâmetro.  
Exemplo:
```{python}
def make_pizza(size,*toppings): #Um argumento posicional e um arbitrário
    #Argumento arbritrário sempre no final
    """Apresenta a pizza que estamos prestes a preparar."""
    print("\nMaking a " + str(size) +
    "-inch pizza with the following toppings:")
    for topping in toppings:
        print(topping)

make_pizza(16,'peperoni') #Chamada com 1 argumento
make_pizza(12,'mushrooms','green peppers','extra cheese') 
#Chamada 1 argumento posicional e 3 argumentos arbitrários
```

Na definição da função, o Python armazena o primeiro valor recebido no parâmetro `size`. Todos os demais valores que vierem depois são armazenados na tupla `toppings`.

\newpage

### Usando argumentos nomeados arbitrários

As vezes você vai querer aceitar um número arbitrário de argumentos, mas não saberá com antecedência qual tipo de informação será passada para a função. Nesse caso, podemos escrever funções que aceitam tantos para `chave-valor` quantos forem fornecidos pela instrução que faz a chamada. Agora ao invés de trabalharmos com **listas** em argumentos arbitrários (argumentos posicionais e arbitrários), trabalhamos com **dicionários** (argumentos nomeados e arbitrários).  
Um exemplo envolve criar perfis de usuários: você sabe que obterá informações sobre um usuário, mas não tem certeza quanto ao tipo de informação que receberá. a função `build_profile()` no próximo exemplo sempre aceita um primeiro nome e um sobrenome, mas aceita também um número **arbitrário de argumentos nomeados**.  
Exemplo:
```{python}
def build_profile(first,last,**user_info):
    """Constrói um dicionário contendo tudo que sabemos sobre o usuário."""
    profile = {}
    profile['first_name'] = first
    profile['last_name'] = last
    for key, value in user_info.items(): #percorre o dicionário parâmetro
        profile[key] = value #Add keys e value do parâmetro no dicionário criado da função
    return profile #Retorna o dicionário criado

user_profile = build_profile('albert', 'einstein', 
                             location = 'princeton',
                             field = 'physics')
print(user_profile)
```

A definição de `build_profile()` espera um primeiro nome e um sobrenome e permite que o usuário passe tantos pares `nome-valor` quanto ele quiser. Os asteriscos duplos (**) antes do parâmetro `**user_info` fazem o Python criar um dicionário vazio chamado `user_info` e colocar quaisquer `nome-valor` recebidos nesse dicionário. Nessa função, podemos acessar os pares `nome-valor` em `user_info` como fariamos com qualquer dicionário.  
No corpo de `build_profile()`, criamos um dicionário vazio chamado `profile` para armazenar o perfil do usuário. Primeiro adicionamos o primeiro nome e o sobre nome nesse dicionário porque sempre receberemos essas duas informações do usuário. Em seguida, percorremos os pares `chave-valor` adicionais do dicionário `user_info` e adicionamos cada par ao dicionário `profile`. Por fim, devolvemos o dicionário `profile` a linha que chamou a função.  
O dicionário devolvido contém o primeiro nome e o sobrenome do usuário e, nesse caso, a localidade e o campo de estudo também. A função será apropriada, não importa quantos pares `chave-valor` adicionais sejam fornecidos na chamada da função.

\newpage

## Armazenando suas funções em módulos

Uma vantagem das funções é a maneira como elas separam blocos de código de seu programa principal. Ao usar nomes descritivos para suas funções, será bem mais fácil entender o seu programa principal. Você pode dar um passo além armazenando suas funções em um arquivo separado chamado **módulo** e, então, *importar* esse módulo em seu programa principal. Uma instrução `import` diz ao Python para deixar o código de um módulo disponível no arquivo de programa em execução no momento.  
Armazenar suas funções em um arquivo separado permite ocultar os detalhes do código de seu programa e se concentrar na lógica de nível mais alto. Também permite reutilizar funções em muitos programas diferentes. Quando armazenamos funções em arquivos separados, podemos compartilhar esses arquivos com outros programadores sem a necessidade de compartilhar o programa todo. Saber como importar funções também possibilita usar bibliotecas de funções que outros programadores escreveram.

### Importando um módulo completo

Para começar a importar funções, inicialmente precisamos criar um módulo. Um módulo é um arquivo terminado em `.py` que contém o código que queremos importar para o nosso programa.  
Exemplo:
```
#Criando módulo = um função para importação
def make_pizza(size,*toppings): #parâmetros, um posicional e um arbitrario (tupla)
    """Apresenta a pizza que estamos prestes a preparar."""
    print("\nMaking a " + str(size) +
          "-inch pizza with the following toppings:")
    for topping in toppings:
        print("- " + topping)
```

Agora criamos um arquivo separado chamado `making_pizza.py` no mesmo diretório em que esta `pizza.py`. Este arquivo importa o módulo que acabamos de criar e, em seguida, faz duas chamadas para a função `make_pizza()`.
```
#Importando módulo
import pizza

#Usando função do módulo
#Módulo.função()
pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms','green peppers','extra cheese')
```

Quando o Python lê esse arquivo, a linha `import pizza` lhe diz para abrir o arquivo `pizza.py` e copiar todas as funções dele para esse programa. Você não vê realmente o código sendo copiado entre os arquivos porque o Python faz isso internamente, a medida que o programa executa. Tudo que você precisa saber é que qualquer função definida em `pizza.py` (arquivo do módulo) agora estará disponível em `making_pizza.py` (arquivo que importa o módulo).  
Para chamar uma função que está em um módulo importado, forneça o nome do módulo, que é `pizza` nesse caso, seguido do nome da função, `make_pizza()`, separados por um ponto. Esse código gera a mesma saída que o programa original, que não importava um módulo.

Essa primeira abordagem à importação, em que simplesmente escrevemos `import` seguido do nome do módulo, deixa todas as funções do módulo disponíveis ao seu programa. Se você usar esse tipo de instrução `import` para importar um módulo completo chamado `nome_do_módulo.py`, todas as funções do módulo estarão disponíveis por meio dessa sintaxe a seguir:  
```
nome_do_módulo.nome_da_função()
```

\newpage

### Importando funções específicas

Podemos também importar uma função específica de um módulo. Eis a sintaxe geral para essa abordagem:  
```
from nome_do_módulo import nome_da_função
```

Você pode importar quantas funções quiser de um módulo separando o nome de cada função com uma virgula:  
```
from nome_do_módulo import função_0, função_1, função_2
```

Com essa sintaxe não precisamos usar a notação de ponto ao chamar uma função do módulo. Por exemplo, quando importamos explicitamente a função make_pizza() na instrução `import`, podemos chamá-la pelo nome quando ela for utilizada.  
```
#Importando função do módulo explicitamente
from pizza import make_pizza

#Usando função do módulo
#Quando importamos o módulo e explicitamos a função, podemos chamar a função diretamente
#Sem usar: nome_modulo.nome_função()
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms','green peppers','extra cheese')
```

\newpage

### Usando a palavra reservada `as` para atribuir um alias a uma função
### Usando a palavra reservada `as` para atribuir um alias a uma módulo
### Importando todas as funções de um módulo

\newpage

## Estilizando funções

\newpage

# Bibliografia